<!DOCTYPE html>
<html>
<head>
	<title>Snake</title>
	<style>
	body {
		display: flex;
  		justify-content: center; /* Centers horizontally */
  		align-items: center; /* Centers vertically */
		width: 100vw;
  		height: 100vh;
		margin: 0;
		padding: 0;
    	background-color: black;
		color: white;
		overflow: hidden;
	}
	#score {
		font-size: 5vh;
		float: left;
		margin: 0;
		padding: 0;
	}
	#highscore {
		font-size: 5vh;
		float: right;
		margin: 0;
		padding: 0;
	}
  	canvas {
	  	height: 100%;
		aspect-ratio: 1 / 1;
	  	border-width: 0px;
		margin: 0;
		padding: 0;
  	}
	#content {
		height: 85vh;
		margin-bottom: 5vh;
		text-align: center;
	}
	#topBar {
		height: 10vh;
		margin: 0;
		padding: 0;
	}
	</style>
</head>
<body>
<div id="content">
	<div id="topBar">
		<div id="score">Score: 0</div>
		<div id="highscore">Highscore: 0</div>
	</div>
	<canvas id="gameCanvas" width="500" height="500"></canvas>
</div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

const queryString = window.location.search;
const urlParams = new URLSearchParams(queryString);
const gamemode = urlParams.get('gamemode') ?? normal; // gamemodes from url, default is normal

const gamemodes = {
	normal: {
		startingFoods: 2,
		startingLength: 5,
		foodWeights: {
			normal: 70,
			boost: 20,
			super: 5,
			multiply: 5
		}
	},
	classic: {
		startingFoods: 1,
		startingLength: 5,
		foodWeights: {
			normal: 100,
			boost: 0,
			super: 0,
			multiply: 0
		}
	}
}

let highscore = Number(localStorage.getItem("snakeHighscore") ?? 0);
document.getElementById("highscore").innerHTML = "Highscore: " + highscore;

let tileSize = canvas.width / 50; // 50 tiles

let score = 0;
const scoreDisplay = document.getElementById('score');

function updateScoreDisplay() {
	scoreDisplay.innerHTML = "Score: " + score;
	// If the current score exceeds the stored highscore, update and persist it
	if (score > highscore) {
		highscore = score;
		localStorage.setItem("snakeHighscore", highscore);
		document.getElementById("highscore").innerHTML = "Highscore: " + highscore;
	}
}

let rainbowMode = localStorage.getItem("rainbowMode") === "true";  // True to enable rainbow mode
// When enabled, head will be hue 0 (red) and each subsequent segment will have an increasing hue offset

const rainbowHeadHue = 110; // 110 = green, 0 = red
const rainbowFillLightness = 30; // Lightness for rainbow fill color
const rainbowStrokeLightness = 10; // Lightness for rainbow stroke color
const rainbowBaseHueStep = 12; // base hue step per segment
const rainbowAcceleration = 1; // accelerates step per segment; set to 1 for linear step

let snakeFill = "#007000";
let snakeStroke = "#005000";

let headFill = "#006000";
let headStroke = "#004000";

let velX = tileSize;
let velY = 0;

let frameDelay = 150;
let frameSpeedIncrease = 0.01;

let isPaused = false;

let snake = [];
for (let i = 0; i < gamemodes[gamemode].startingLength; i++) {
    snake.push({x: tileSize * 8 - i * tileSize, y: tileSize * 8}); // Create the snake parts starting 8 tiles down and 8 tiles to the right
}

function clearCanvas() {
	ctx.fillStyle = "white";
	ctx.fillRect(0, 0, canvas.width, canvas.height);
}

function randomBetween(min, max, roundTo) {
  if (roundTo <= 0) throw new Error("roundTo must be > 0");
  const range = Math.floor((max - min) / roundTo);
  const randomStep = Math.floor(Math.random() * (range + 1));
  return min + randomStep * roundTo;
}


function advanceSnake() {
    const head = { x: snake[0].x + velX, y: snake[0].y + velY };
    snake.unshift(head);

    let eatenIndex = foods.findIndex(f => f.x === head.x && f.y === head.y);
    if (eatenIndex !== -1) {
        const food = foods[eatenIndex];
        food.effect();

        if (food.lengthChange < 0) {
            for (let i = 0; i < Math.abs(food.lengthChange); i++) {
                if (snake.length > 1) snake.pop();
            }
        } else {
            for (let i = 0; i < food.lengthChange - 1; i++) {
                snake.push({ ...snake[snake.length - 1] }); // duplicate tail
            }
        }

        foods.splice(eatenIndex, 1);
        spawnRandomFood();
    } else {
        snake.pop();
    }

    directionChanged = false;
}



function drawSnakePart(snakePart, index) {
	if (rainbowMode) { // Rainbow mode colors
		let hue;
		if (index === 0) {
			hue = rainbowHeadHue;
		} else {
			// Sum an accelerating series to get a smoothly increasing offset across segments.
			// If acceleration==1, just use linear step.
			let offset;
			if (rainbowAcceleration === 1) {
				offset = rainbowBaseHueStep * index;
			} else {
				offset = rainbowBaseHueStep * (Math.pow(rainbowAcceleration, index) - 1) / (rainbowAcceleration - 1);
			}
			hue = (rainbowHeadHue + offset) % 360;
		}
		ctx.fillStyle = `hsl(${hue}, 70%, ${rainbowFillLightness}%)`;
		ctx.strokeStyle = `hsl(${hue}, 60%, ${rainbowStrokeLightness}%)`;
	} else { // Normal colors
		if (index === 0) {
			ctx.fillStyle = headFill;
			ctx.strokeStyle = headStroke;
		} else {
			ctx.fillStyle = snakeFill;
			ctx.strokeStyle = snakeStroke;
		}
	}
	ctx.strokeRect(snakePart.x, snakePart.y, tileSize, tileSize);
	ctx.fillRect(snakePart.x, snakePart.y, tileSize, tileSize);
}

function drawSnake() {
	snake.forEach((part, idx) => drawSnakePart(part, idx));
}

let foods = [];

class Food {
    constructor(x, y, type = "normal") {
        this.x = x;
        this.y = y;
        this.type = type;
        this.color = Food.types[type].color;
		this.size = Food.types[type].size;
        this.effect = Food.types[type].effect;
        this.lengthChange = Food.types[type].lengthChange;
    }

    static types = {
        normal: {
            color: { fill: "#ff0000", stroke: "#900000" },
			size: 1,
			effect: () => {
				score++;
				frameDelay *= 1 - frameSpeedIncrease; 
				updateScoreDisplay();
			},
			lengthChange: 1,
			weight: gamemodes[gamemode].foodWeights.normal
        },
        boost: {
            color: { fill: "#00ff00", stroke: "#009900" },
			size: 1.5,
			effect: () => {
				score += 3;
				frameDelay *= 1 - frameSpeedIncrease * 2; 
				updateScoreDisplay();
			},
			lengthChange: 2,
			weight: gamemodes[gamemode].foodWeights.boost
        },
        super: {
            color: { fill: "#00ffff", stroke: "#000000" },
			size: 2,
			effect: () => {
				score += 10;
				frameDelay *= 1 - frameSpeedIncrease * 3;
				updateScoreDisplay();
			},
			lengthChange: 5,
			weight: gamemodes[gamemode].foodWeights.super
        },
		multiply: {
            color: { fill: "#ff00ff", stroke: "#900090" },
			size: 1,
			effect: () => {
				spawnRandomFood(); // Spawn an extra food to increase number of foods on screen
				updateScoreDisplay();
			},
			lengthChange: 0,
			weight: gamemodes[gamemode].foodWeights.multiply
        }
    };
}

function spawnFood(type = "normal") {
    let x, y;
    do {
        x = randomBetween(0, canvas.width - tileSize, tileSize);
        y = randomBetween(0, canvas.height - tileSize, tileSize);
    } while (snake.some(part => part.x === x && part.y === y));

    foods.push(new Food(x, y, type));
}

function spawnRandomFood() {
	// Build weight map from Food.types so weights are defined in one place.
	const foodSpawnWeights = {};
	for (const [type, def] of Object.entries(Food.types)) {
		foodSpawnWeights[type] = def.weight ?? 0;
	}

	function pickWeightedType(weights) {
		const entries = Object.entries(weights);
		const total = entries.reduce((sum, [, w]) => sum + w, 0);
		let r = Math.random() * total;
		for (const [type, w] of entries) {
			if (r < w) return type;
			r -= w;
		}
		return entries[entries.length - 1][0];
	}

	const type = pickWeightedType(foodSpawnWeights);
	spawnFood(type);
}


function drawFood() {
	foods.forEach(food => {
		const centerX = food.x + tileSize / 2;
		const centerY = food.y + tileSize / 2;
		const padding = Math.max(2, tileSize * 0.12);
		const radius = (tileSize / 2) * food.size - padding;
		ctx.beginPath();
		ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
		ctx.fillStyle = food.color.fill;
		ctx.fill();
		ctx.lineWidth = Math.max(1, tileSize * 0.04);
		ctx.strokeStyle = food.color.stroke;
		ctx.stroke();
	});
}


let direction = "right";
let directionChanged = false;

function updateDirection(event) {
	if(!directionChanged) { // Only change direction once per frame;
		const keyPressed = event.key;
		
		if ((keyPressed === "w" || keyPressed === "ArrowUp") && direction != "down") {
			velX = 0;
			velY = -tileSize;
			
			direction = "up";
			directionChanged = true;
		}
		if ((keyPressed === "s" || keyPressed === "ArrowDown") && direction != "up") {
			velX = 0;
			velY = tileSize;
			
			direction = "down";
			directionChanged = true;
		}
		if ((keyPressed === "a" || keyPressed === "ArrowLeft") && direction != "right") {
			velX = -tileSize;
			velY = 0;
			
			direction = "left";
			directionChanged = true;
		}
		if ((keyPressed === "d" || keyPressed === "ArrowRight") && direction != "left") {
			velX = tileSize;
			velY = 0;
			
			direction = "right";
			directionChanged = true;
		}
	}
}

function isDead() {
	for (let i = 4; i < snake.length; i++) {
		const didCollide = snake[i].x === snake[0].x &&snake[i].y === snake[0].y; // Check if any part has collided with the head
		if (didCollide) return true;
	}
	// Check if hit any walls
	const hitLeftWall = snake[0].x < 0;
	const hitRightWall = snake[0].x > gameCanvas.width - tileSize;
	const hitTopWall = snake[0].y < 0;
	const hitBottomWall = snake[0].y > gameCanvas.height - tileSize;
	
	return hitLeftWall || hitRightWall || hitTopWall || hitBottomWall; // True if any walls are hit
}

function die() {
	// Semi-transparent overlay
	ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
	ctx.fillRect(0, 0, canvas.width, canvas.height);
	// Game over text
	ctx.font = "50px Arial";
    ctx.fillStyle = "red";
	ctx.strokeStyle = "black";
    ctx.textAlign = "center";
	ctx.fillText("Game Over!", canvas.width / 2, canvas.height / 2);
	ctx.strokeText("Game Over!", canvas.width / 2, canvas.height / 2);
	// Space to continue text
	ctx.font = "20px Arial";
	ctx.fillStyle = "yellow";
    ctx.textAlign = "center";
	ctx.fillText("Press space to try again", canvas.width / 2, canvas.height / 2 + 50);
	
	// if score higher than highscore, set as highscore
	if(score > highscore) {
		localStorage.setItem("snakeHighscore", score);
	}
}

function drawPauseScreen() {
	// Semi-transparent overlay
	ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
	ctx.fillRect(0, 0, canvas.width, canvas.height);
	// Paused text
	ctx.font = "50px Arial";
	ctx.fillStyle = "cyan";
	ctx.textAlign = "center";
	ctx.fillText("Paused", canvas.width / 2, canvas.height / 2);
	// Resume instructions
	ctx.font = "20px Arial";
	ctx.fillStyle = "yellow";
	ctx.textAlign = "center";
	ctx.fillText("Press escape to resume", canvas.width / 2, canvas.height / 2 + 50);
}

function newFrame() {
	clearCanvas();
	if(!isPaused) {
		advanceSnake(); // Advance snake and then draw it
		drawSnake();
		drawFood();
	} else {
		drawSnake(); // Draw snake and food before drawing pause screen
		drawFood();
		drawPauseScreen();
	}
	
	// Die if dead, otherwise continue the game
	if(isDead()) { 
		die();
	} else {
		setTimeout(newFrame, frameDelay);
	}
}

// Refresh if space pressed while dead
document.addEventListener("keydown", (event) => {
	if (event.key === " " && isDead()) {
		window.location.reload(); // Reload page
	}
});

document.addEventListener("keydown", (event) => {
	if (event.key === "Escape") {
		isPaused = !isPaused;
	}
});

document.addEventListener("keydown", (event) => {
	if (event.key === "r") {
		rainbowMode = !rainbowMode;
		localStorage.setItem("rainbowMode", rainbowMode.toString());
	}
});

document.addEventListener("keydown", updateDirection);
// Spawn initial foods based on gamemode
for(i=0; i<gamemodes[gamemode].startingFoods; i++) {
	spawnRandomFood();
}

setTimeout(newFrame, frameDelay); // Start the game
</script>
</body>
</html>
