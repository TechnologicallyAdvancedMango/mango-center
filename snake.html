<!DOCTYPE html>
<html>
<head>
	<title>Snake</title>
	<style>
	body {
		display: flex;
  		justify-content: center; /* Centers horizontally */
  		align-items: center; /* Centers vertically */
		width: 100vw;
  		height: 100vh;
		margin: 0;
		padding: 0;
    	background-color: black;
		color: white;
		overflow: hidden;
	}
	#score {
		font-size: 5vh;
		float: left;
		margin: 0;
		padding: 0;
	}
	#highscore {
		font-size: 5vh;
		float: right;
		margin: 0;
		padding: 0;
	}
  	canvas {
	  	height: 100%;
		aspect-ratio: 1 / 1;
	  	border-width: 0px;
		margin: 0;
		padding: 0;
  	}
	#content {
		height: 85vh;
		margin-bottom: 5vh;
		text-align: center;
	}
	#topBar {
		height: 10vh;
		margin: 0;
		padding: 0;
	}
	</style>
</head>
<body>
<div id="content">
	<div id="topBar">
		<div id="score">Score: 0</div>
		<div id="highscore">Highscore: 0</div>
	</div>
	<canvas id="gameCanvas"></canvas>
</div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

// Match internal resolution to CSS size
canvas.width = canvas.clientWidth;
canvas.height = canvas.clientHeight;

const queryString = window.location.search;
const urlParams = new URLSearchParams(queryString);
const gamemode = (urlParams.get('gamemode') || "normal").toLowerCase(); // gamemodes from url, default is normal

const gamemodes = {
	normal: {
		startingFoods: 2,
		startingLength: 5,
		gridSize: 30,
		foodWeights: {
			normal: 70,
			boost: 20,
			super: 5,
			multiply: 5
		},
		god: false
	},
	classic: {
		startingFoods: 1,
		startingLength: 3,
		gridSize: 16,
		foodWeights: {
			normal: 100,
			boost: 0,
			super: 0,
			multiply: 0
		},
		god: false
	},
	chaos: {
		startingFoods: 2000,
		startingLength: 2,
		gridSize: 50,
		foodWeights: {
			normal: 0,
			boost: 0,
			super: 0,
			multiply: 100
		},
		god: false
	},
	creative: {
		startingFoods: 0,
		startingLength: 5,
		gridSize: 30,
		foodWeights: {
			normal: 70,
			boost: 20,
			super: 5,
			multiply: 5
		},
		god: true
	}
}

let god = false;
if(gamemodes[gamemode].god) god = true;

let highscore = Number(localStorage.getItem("snakeHighscore") ?? 0);
document.getElementById("highscore").innerHTML = "Highscore: " + highscore;

let gridSize = gamemodes[gamemode].gridSize;

let tileSize = canvas.width / gridSize;

let score = 0;
const scoreDisplay = document.getElementById('score');

function updateScoreDisplay() {
	scoreDisplay.innerHTML = "Score: " + score;
	// If the current score exceeds the stored highscore, update and persist it
	if (score > highscore) {
		highscore = score;
		localStorage.setItem("snakeHighscore", highscore);
		document.getElementById("highscore").innerHTML = "Highscore: " + highscore;
	}
}

let rainbowMode = localStorage.getItem("rainbowMode") === "true";  // True to enable rainbow mode
// When enabled, head will be hue 0 (red) and each subsequent segment will have an increasing hue offset

const rainbowHeadHue = 110; // 110 = green, 0 = red
const rainbowFillLightness = 30; // Lightness for rainbow fill color
const rainbowStrokeLightness = 10; // Lightness for rainbow stroke color
const rainbowBaseHueStep = 12; // base hue step per segment
const rainbowAcceleration = 1; // accelerates step per segment; set to 1 for linear step

let doDrawSnakeConnected = localStorage.getItem("doDrawSnakeConnected") === "true";

let doDrawGrid = parseInt(localStorage.getItem("doDrawGrid")) || 0; // 0 is off, 1 is lines touching the head, 2 is on

let snakeFill = "#007000";
let snakeStroke = "#005000";

let headFill = "#009000";
let headStroke = "#007000";

let velX = tileSize;
let velY = 0;

let frameDelay = 150;
let frameSpeedIncrease = 0.005;

let isPaused = false;

let snake = [];
for (let i = 0; i < gamemodes[gamemode].startingLength; i++) {
    snake.push({x: tileSize * 3 - i * tileSize, y: tileSize * 5}); // Create the snake parts starting 5 tiles down and 3 tiles to the right
}

function clearCanvas() {
	ctx.fillStyle = "white";
	ctx.fillRect(0, 0, canvas.width, canvas.height);
}

function drawGrid() {
	if (doDrawGrid === 0) return;

	ctx.strokeStyle = "#d0d0d0";
	ctx.lineWidth = 1;

	if (doDrawGrid === 1) {
		const head = snake[0]; // pixel coords
		const leftX   = head.x;
		const rightX  = head.x + tileSize;
		const topY    = head.y;
		const bottomY = head.y + tileSize;

		// Vertical bounds
		ctx.beginPath();
		ctx.moveTo(leftX, 0);
		ctx.lineTo(leftX, canvas.height);
		ctx.stroke();

		ctx.beginPath();
		ctx.moveTo(rightX, 0);
		ctx.lineTo(rightX, canvas.height);
		ctx.stroke();

		// Horizontal bounds
		ctx.beginPath();
		ctx.moveTo(0, topY);
		ctx.lineTo(canvas.width, topY);
		ctx.stroke();

		ctx.beginPath();
		ctx.moveTo(0, bottomY);
		ctx.lineTo(canvas.width, bottomY);
		ctx.stroke();
	} else if (doDrawGrid === 2) {
		// vertical lines
		for(let x = 0; x <= gridSize; x++) {
			ctx.beginPath();
			ctx.moveTo(x * tileSize, 0);
			ctx.lineTo(x * tileSize, canvas.height);
			ctx.stroke();
		}

		// horizontal lines
		for(let y = 0; y <= gridSize; y++) {
			ctx.beginPath();
			ctx.moveTo(0, y * tileSize);
			ctx.lineTo(canvas.width, y * tileSize);
			ctx.stroke();
		}
	}
}

function randomBetween(min, max, roundTo) {
  if (roundTo <= 0) throw new Error("roundTo must be > 0");
  const range = Math.floor((max - min) / roundTo);
  const randomStep = Math.floor(Math.random() * (range + 1));
  return min + randomStep * roundTo;
}


function advanceSnake() {
    const head = {
		x: Math.round((snake[0].x + velX) / tileSize) * tileSize,
		y: Math.round((snake[0].y + velY) / tileSize) * tileSize
	};
    snake.unshift(head);

    let eatenIndex = foods.findIndex(f =>
		head.x === f.x && head.y === f.y
	);

    if (eatenIndex !== -1) {
        const food = foods[eatenIndex];
        food.effect();

        if (food.lengthChange < 0) {
            for (let i = 0; i < Math.abs(food.lengthChange); i++) {
                if (snake.length > 1) snake.pop();
            }
        } else  if (food.lengthChange > 0) {
            for (let i = 0; i < food.lengthChange - 1; i++) {
                snake.push({ ...snake[snake.length - 1] }); // duplicate tail
            }
        }

        foods.splice(eatenIndex, 1);
        spawnRandomFood();
    } else {
        snake.pop();
    }

    directionChanged = false;
}



function drawSnakePart(snakePart, index) {
	if (rainbowMode) { // Rainbow mode colors
		let hue;
		if (index === 0) {
			hue = rainbowHeadHue;
		} else {
			// Sum an accelerating series to get a smoothly increasing offset across segments.
			// If acceleration==1, just use linear step.
			let offset;
			if (rainbowAcceleration === 1) {
				offset = rainbowBaseHueStep * index;
			} else {
				offset = rainbowBaseHueStep * (Math.pow(rainbowAcceleration, index) - 1) / (rainbowAcceleration - 1);
			}
			hue = (rainbowHeadHue + offset) % 360;
		}
		ctx.fillStyle = `hsl(${hue}, 90%, ${rainbowFillLightness}%)`;
		ctx.strokeStyle = `hsl(${hue}, 80%, ${rainbowStrokeLightness}%)`;
	} else { // Normal colors
		if (index === 0) {
			ctx.fillStyle = headFill;
			ctx.strokeStyle = headStroke;
		} else {
			ctx.fillStyle = snakeFill;
			ctx.strokeStyle = snakeStroke;
		}
	}
	ctx.strokeRect(snakePart.x, snakePart.y, tileSize, tileSize);
	ctx.fillRect(snakePart.x, snakePart.y, tileSize, tileSize);
}

function drawSnake() {
	if (doDrawSnakeConnected) {
		drawSnakeConnected();
	} else {
		for (i = snake.length - 1; i >= 0; i--) { // draws last to first to that the head is always on top
			drawSnakePart(snake[i], i);
		}
	}
}

function drawSnakeConnected() {
    ctx.lineWidth = tileSize;
    ctx.lineJoin = "round";
    ctx.lineCap = "round";

    if (rainbowMode) {
        for (let i = 0; i < snake.length - 1; i++) {
            const x1 = snake[i].x + tileSize / 2;
            const y1 = snake[i].y + tileSize / 2;
            const x2 = snake[i+1].x + tileSize / 2;
            const y2 = snake[i+1].y + tileSize / 2;

            // Calculate hue for this segment based on position
            const hue1 = (rainbowHeadHue + i * rainbowBaseHueStep * rainbowAcceleration) % 360;
            const hue2 = (rainbowHeadHue + (i+1) * rainbowBaseHueStep * rainbowAcceleration) % 360;

            // Gradient along this segment
            const grad = ctx.createLinearGradient(x1, y1, x2, y2);
            grad.addColorStop(0, `hsl(${hue1}, 100%, ${rainbowFillLightness}%)`);
            grad.addColorStop(1, `hsl(${hue2}, 100%, ${rainbowFillLightness}%)`);

            ctx.strokeStyle = grad;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }
    } else {
        // Normal single-color snake
        ctx.strokeStyle = snakeFill;

        ctx.beginPath();
        ctx.moveTo(snake[0].x + tileSize / 2, snake[0].y + tileSize / 2);
        for (let i = 1; i < snake.length; i++) {
            ctx.lineTo(snake[i].x + tileSize / 2, snake[i].y + tileSize / 2);
        }
        ctx.stroke();
    }
}

let foods = [];

class Food {
    constructor(x, y, type = "normal") {
        this.x = x;
        this.y = y;
        this.type = type;
        this.color = Food.types[type].color;
		this.size = Food.types[type].size;
        this.effect = Food.types[type].effect;
        this.lengthChange = Food.types[type].lengthChange;
    }

    static types = {
        normal: {
            color: { fill: "#ff0000", stroke: "#900000" },
			size: 1,
			effect: () => {
				score++;
				frameDelay *= 1 - frameSpeedIncrease; 
				updateScoreDisplay();
			},
			lengthChange: 1,
			weight: gamemodes[gamemode].foodWeights.normal
        },
        boost: {
            color: { fill: "#00ff00", stroke: "#009900" },
			size: 1.2,
			effect: () => {
				score += 3;
				frameDelay *= 1 - frameSpeedIncrease * 2; 
				updateScoreDisplay();
			},
			lengthChange: 2,
			weight: gamemodes[gamemode].foodWeights.boost
        },
        super: {
            color: { fill: "#00ffff", stroke: "#000000" },
			size: 1.6,
			effect: () => {
				score += 10;
				frameDelay *= 1 - frameSpeedIncrease * 3;
				updateScoreDisplay();
			},
			lengthChange: 5,
			weight: gamemodes[gamemode].foodWeights.super
        },
		multiply: {
            color: { fill: "#ff00ff", stroke: "#900090" },
			size: 1,
			effect: () => {
				spawnRandomFood(); // Spawn an extra food to increase number of foods on screen
				updateScoreDisplay();
			},
			lengthChange: 0,
			weight: gamemodes[gamemode].foodWeights.multiply
        }
    };
}

function spawnFood(type = "normal") {
    let x, y;
    do {
        x = randomBetween(0, canvas.width - tileSize, tileSize);
        y = randomBetween(0, canvas.height - tileSize, tileSize);
    } while (snake.some(part => part.x === x && part.y === y) || foods.some(food => food.x === x && food.y === y)); // Check if snake parts or any foods overlap the food and keep respawning until it isn't

    foods.push(new Food(x, y, type));
}

function spawnRandomFood() {
	// Build weight map from Food.types which comes from gamemode
	const foodSpawnWeights = {};
	for (const [type, def] of Object.entries(Food.types)) {
		foodSpawnWeights[type] = def.weight ?? 0;
	}

	function pickWeightedType(weights) {
		const entries = Object.entries(weights);
		const total = entries.reduce((sum, [, w]) => sum + w, 0);
		let r = Math.random() * total;
		for (const [type, w] of entries) {
			if (r < w) return type;
			r -= w;
		}
		return entries[entries.length - 1][0];
	}

	const type = pickWeightedType(foodSpawnWeights);
	spawnFood(type);
}


function drawFood() {
	foods.forEach(food => {
		const centerX = food.x + tileSize / 2;
		const centerY = food.y + tileSize / 2;
		const padding = Math.max(2, tileSize * 0.12);
		const radius = (tileSize / 2) * food.size - padding;
		ctx.beginPath();
		ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
		ctx.fillStyle = food.color.fill;
		ctx.fill();
		ctx.lineWidth = Math.max(1, tileSize * 0.04);
		ctx.strokeStyle = food.color.stroke;
		ctx.stroke();
	});
}


let direction = "right";
let directionChanged = false;

function updateDirection(event) {
	if(!directionChanged) { // Only change direction once per frame;
		const keyPressed = event.key;
		
		if ((keyPressed === "w" || keyPressed === "ArrowUp") && direction != "down") {
			velX = 0;
			velY = -tileSize;
			
			direction = "up";
			directionChanged = true;
		}
		if ((keyPressed === "s" || keyPressed === "ArrowDown") && direction != "up") {
			velX = 0;
			velY = tileSize;
			
			direction = "down";
			directionChanged = true;
		}
		if ((keyPressed === "a" || keyPressed === "ArrowLeft") && direction != "right") {
			velX = -tileSize;
			velY = 0;
			
			direction = "left";
			directionChanged = true;
		}
		if ((keyPressed === "d" || keyPressed === "ArrowRight") && direction != "left") {
			velX = tileSize;
			velY = 0;
			
			direction = "right";
			directionChanged = true;
		}
	}
}

function isDead() {
	for (let i = 4; i < snake.length; i++) {
		const didCollide = snake[i].x === snake[0].x &&snake[i].y === snake[0].y; // Check if any part has collided with the head
		if (didCollide) return true;
	}
	// Check if hit any walls
	const hitLeftWall = snake[0].x < 0;
	const hitRightWall = snake[0].x > gameCanvas.width - tileSize;
	const hitTopWall = snake[0].y < 0;
	const hitBottomWall = snake[0].y > gameCanvas.height - tileSize;
	
	return hitLeftWall || hitRightWall || hitTopWall || hitBottomWall; // True if any walls are hit
}

function die() {
	// Semi-transparent overlay
	ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
	ctx.fillRect(0, 0, canvas.width, canvas.height);
	// Game over text
	ctx.font = "50px Arial";
    ctx.fillStyle = "red";
	ctx.strokeStyle = "black";
    ctx.textAlign = "center";
	ctx.fillText("Game Over!", canvas.width / 2, canvas.height / 2);
	ctx.strokeText("Game Over!", canvas.width / 2, canvas.height / 2);
	// Space to continue text
	ctx.font = "20px Arial";
	ctx.fillStyle = "yellow";
    ctx.textAlign = "center";
	ctx.fillText("Press space to try again", canvas.width / 2, canvas.height / 2 + 50);
	
	// if score higher than highscore, set as highscore
	if(score > highscore) {
		localStorage.setItem("snakeHighscore", score);
	}
}

function drawPauseScreen() {
	// Semi-transparent overlay
	ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
	ctx.fillRect(0, 0, canvas.width, canvas.height);
	// Paused text
	ctx.font = "50px Arial";
	ctx.fillStyle = "cyan";
	ctx.textAlign = "center";
	ctx.fillText("Paused", canvas.width / 2, canvas.height / 2);
	// Resume instructions
	ctx.font = "20px Arial";
	ctx.fillStyle = "yellow";
	ctx.textAlign = "center";
	ctx.fillText("Press escape to resume", canvas.width / 2, canvas.height / 2 + 50);
}

function newFrame() {
	clearCanvas();
	if(isPaused) {
		drawGrid();
		drawSnake();
		drawFood();
		drawPauseScreen();
	} else {
		advanceSnake();

		drawGrid();
		drawSnake();
		drawFood();
	}
	
	// Die if dead, otherwise continue the game
	if(isDead() && !god) { 
		die();
	} else {
		setTimeout(newFrame, frameDelay);
	}
}

// Refresh if space pressed while dead
document.addEventListener("keydown", (event) => {
	if (event.key === " " && isDead()) {
		window.location.reload(); // Reload page
	}
});

document.addEventListener("keydown", (event) => {
	if (event.key === "Escape") {
		isPaused = !isPaused;
	}
});

document.addEventListener("keydown", (event) => {
	if (event.key === "r") {
		rainbowMode = !rainbowMode;
		localStorage.setItem("rainbowMode", rainbowMode.toString());
	}
	if (event.key === "c") {
		doDrawSnakeConnected = !doDrawSnakeConnected;
		localStorage.setItem("doDrawSnakeConnected", doDrawSnakeConnected.toString());
	}
	if (event.key === "g") {
		doDrawGrid = (doDrawGrid + 1) % 3;
		localStorage.setItem("doDrawGrid", doDrawGrid.toString());
	}
});

document.addEventListener("keydown", (event) => {
	if (gamemode === "creative") {
		if (event.which === 187) { // "+" key
			snake.push(snake[snake.length - 1]); // Lengthen snake by 1
		}
		if (event.which === 189) { // "-" key
			snake.pop(); // Shorten snake by 1
		}
	}
});

document.addEventListener("keydown", updateDirection);
// Spawn initial foods based on gamemode
for(i=0; i<gamemodes[gamemode].startingFoods; i++) {
	spawnRandomFood();
}
newFrame(); // Start the game
</script>
</body>
</html>
