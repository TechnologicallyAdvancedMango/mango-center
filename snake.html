<!DOCTYPE html>
<html>
<head>
	<title>Snake</title>
	<style>
	body {
		display: flex;
  		justify-content: center; /* Centers horizontally */
  		align-items: center; /* Centers vertically */
		width: 100vw;
  		height: 100vh;
		margin: 0;
		padding: 0;
    	background-color: black;
		color: white;
		overflow: hidden;
	}
	#score {
		font-size: 5vh;
		float: left;
		margin: 0;
		padding: 0;
	}
	#highscore {
		font-size: 5vh;
		float: right;
		margin: 0;
		padding: 0;
	}
  	canvas {
	  	height: 100%;
		aspect-ratio: 1 / 1;
	  	border-width: 0px;
		margin: 0;
		padding: 0;
  	}
	#content {
		height: 85vh;
		margin-bottom: 5vh;
		text-align: center;
	}
	#topBar {
		height: 10vh;
		margin: 0;
		padding: 0;
	}
	</style>
</head>
<body>
<div id="content">
	<div id="topBar">
		<div id="score">Score: 0</div>
		<div id="highscore">Highscore: 0</div>
	</div>
	<canvas id="gameCanvas" width="500" height="500"></canvas>
</div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

let highscore = Number(localStorage.getItem("snakeHighscore") ?? 0);
document.getElementById("highscore").innerHTML = "Highscore: " + highscore;

let tileSize = canvas.width / 25; // 25 tiles

let score = 0;
const scoreDisplay = document.getElementById('score');

function updateScoreDisplay() {
	scoreDisplay.innerHTML = "Score: " + score;
	// If the current score exceeds the stored highscore, update and persist it
	if (score > highscore) {
		highscore = score;
		localStorage.setItem("snakeHighscore", highscore);
		document.getElementById("highscore").innerHTML = "Highscore: " + highscore;
	}
}

let snakeFill = "#007000";
let snakeStroke = "#005000";

let foodFill = "#ff0000";
let foodStroke = "#900000";

let velX = tileSize;
let velY = 0;

let frameDelay = 150;
let frameSpeedIncrease = 0.01;

let snake = [];
for (let i = 0; i < 5; i++) {
    snake.push({x: tileSize * 8 - i * tileSize, y: tileSize * 8}); // Create the snake parts starting 8 tiles down and 8 tiles to the right
}

function clearCanvas() {
	ctx.fillStyle = "white";
	ctx.fillRect(0, 0, canvas.width, canvas.height);
}

function randomBetween(min, max, roundTo) {
  if (roundTo <= 0) throw new Error("roundTo must be > 0");
  const range = Math.floor((max - min) / roundTo);
  const randomStep = Math.floor(Math.random() * (range + 1));
  return min + randomStep * roundTo;
}


function advanceSnake() {
    const head = { x: snake[0].x + velX, y: snake[0].y + velY };
    snake.unshift(head);

    let eatenIndex = foods.findIndex(f => f.x === head.x && f.y === head.y);
    if (eatenIndex !== -1) {
        const food = foods[eatenIndex];
        food.effect();

        if (food.lengthChange < 0) {
            for (let i = 0; i < Math.abs(food.lengthChange); i++) {
                if (snake.length > 1) snake.pop();
            }
        } else {
            for (let i = 0; i < food.lengthChange - 1; i++) {
                snake.push({ ...snake[snake.length - 1] }); // duplicate tail
            }
        }

        foods.splice(eatenIndex, 1);
        spawnRandomFood();
    } else {
        snake.pop();
    }

    directionChanged = false;
}



function drawSnakePart(snakePart) {
	ctx.fillStyle = snakeFill;
	ctx.strokeStyle = snakeStroke;
	ctx.fillRect(snakePart.x, snakePart.y, tileSize, tileSize);
	ctx.strokeRect(snakePart.x, snakePart.y, tileSize, tileSize);
}

function drawSnake() {
	snake.forEach(drawSnakePart);
}

let foods = [];

class Food {
    constructor(x, y, type = "normal") {
        this.x = x;
        this.y = y;
        this.type = type;
        this.color = Food.types[type].color;
        this.effect = Food.types[type].effect;
        this.lengthChange = Food.types[type].lengthChange;
    }

    static types = {
        normal: {
            color: { fill: "#ff0000", stroke: "#900000" },
			effect: () => {
				score++;
				frameDelay *= 1 - frameSpeedIncrease; 
				updateScoreDisplay();
			},
			lengthChange: 1,
			weight: 70
        },
        boost: {
            color: { fill: "#00ff00", stroke: "#009900" },
			effect: () => {
				score += 2;
				frameDelay *= 1 - frameSpeedIncrease * 2; 
				updateScoreDisplay();
			},
			lengthChange: 2,
			weight: 20
        },
        super: {
            color: { fill: "#00ffff", stroke: "#000000" },
			effect: () => {
				score++;
				frameDelay *= 1 - frameSpeedIncrease * 3;
				updateScoreDisplay();
			},
			lengthChange: 5,
			weight: 10
        }
    };
}

function spawnFood(type = "normal") {
    let x, y;
    do {
        x = randomBetween(0, canvas.width - tileSize, tileSize);
        y = randomBetween(0, canvas.height - tileSize, tileSize);
    } while (snake.some(part => part.x === x && part.y === y));

    foods.push(new Food(x, y, type));
}

function spawnRandomFood() {
	// Build weight map from Food.types so weights are defined in one place.
	const foodSpawnWeights = {};
	for (const [type, def] of Object.entries(Food.types)) {
		foodSpawnWeights[type] = def.weight ?? 0;
	}

	function pickWeightedType(weights) {
		const entries = Object.entries(weights);
		const total = entries.reduce((sum, [, w]) => sum + w, 0);
		let r = Math.random() * total;
		for (const [type, w] of entries) {
			if (r < w) return type;
			r -= w;
		}
		return entries[entries.length - 1][0];
	}

	const type = pickWeightedType(foodSpawnWeights);
	spawnFood(type);
}


function drawFood() {
    foods.forEach(food => {
        ctx.fillStyle = food.color.fill;
        ctx.strokeStyle = food.color.stroke;
        ctx.fillRect(food.x, food.y, tileSize, tileSize);
        ctx.strokeRect(food.x, food.y, tileSize, tileSize);
    });
}


let direction = "right";
let directionChanged = false;

function updateDirection(event) {
	if(!directionChanged) { // Only change direction once per frame;
		const keyPressed = event.key;
		
		if ((keyPressed === "w" || keyPressed === "ArrowUp") && direction != "down") {
			velX = 0;
			velY = -tileSize;
			
			direction = "up";
			directionChanged = true;
		}
		if ((keyPressed === "s" || keyPressed === "ArrowDown") && direction != "up") {
			velX = 0;
			velY = tileSize;
			
			direction = "down";
			directionChanged = true;
		}
		if ((keyPressed === "a" || keyPressed === "ArrowLeft") && direction != "right") {
			velX = -tileSize;
			velY = 0;
			
			direction = "left";
			directionChanged = true;
		}
		if ((keyPressed === "d" || keyPressed === "ArrowRight") && direction != "left") {
			velX = tileSize;
			velY = 0;
			
			direction = "right";
			directionChanged = true;
		}
	}
}

function isDead() {
	for (let i = 4; i < snake.length; i++) {
		const didCollide = snake[i].x === snake[0].x &&snake[i].y === snake[0].y; // Check if any part has collided with the head
		if (didCollide) return true;
	}
	// Check if hit any walls
	const hitLeftWall = snake[0].x < 0;
	const hitRightWall = snake[0].x > gameCanvas.width - tileSize;
	const hitTopWall = snake[0].y < 0;
	const hitBottomWall = snake[0].y > gameCanvas.height - tileSize;
	
	return hitLeftWall || hitRightWall || hitTopWall || hitBottomWall; // True if any walls are hit
}

function die() {
	// Game over text
	ctx.font = "50px Arial";
    ctx.fillStyle = "red";
    ctx.textAlign = "center";
	ctx.fillText("Game Over!", canvas.width / 2, canvas.height / 2);
	// Space to continue text
	ctx.font = "20px Arial";
    ctx.fillStyle = "black";
	ctx.strokeStyle = "yellow";
    ctx.textAlign = "center";
	ctx.strokeText("Press space to try again", canvas.width / 2, canvas.height / 2 + 50);
	ctx.fillText("Press space to try again", canvas.width / 2, canvas.height / 2 + 50);
	
	// if score higher than highscore, set as highscore
	if(score > highscore) {
		localStorage.setItem("snakeHighscore", score);
	}
}

function newFrame() {
	clearCanvas();
	advanceSnake();
	drawSnake();
	drawFood();
	
	// die if dead, otherwise continue the game
	if(isDead()) { 
		die();
	} else {
		setTimeout(newFrame, frameDelay);
	}
}

// Refresh if space pressed while dead
document.addEventListener("keydown", (event) => {
	if (event.key === " " && isDead()) {
		window.location.reload(); // Reload page
	}
});

document.addEventListener("keydown", updateDirection);
spawnRandomFood(); // Spawn initial foods
spawnRandomFood();
setTimeout(newFrame, frameDelay); // Start the game
</script>
</body>
</html>