<!doctype html>
<html>
<head>
	<title>Dodge</title>
	<link rel="icon" type="image/x-icon" href="/images/dodge.png">
<style>
	body{
		background-color: black;
		
		margin: 0;
		padding: 0;
		overflow: hidden;
	}

	#canvas{
		border-color: red;
		border-width: 0px;
		border-style: solid;

		background-color: black;
		
		margin: 0;
		padding: 0;
	}
</style>
</head>
<body>
<canvas id="canvas" width="100" height="100"></canvas>
<button id="respawnBtn" onclick="respawn()" style="
    display: none;
    position: fixed;
    top: 60%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 9999;
    font-size: 24px;
    padding: 10px 20px;
    background-color: #222;
    color: #fff;
    border: 2px solid #40ff90;
    border-radius: 8px;
    cursor: pointer;
">
    Respawn
</button>
<input id="debugCodeInput" type="text" placeholder="Enter debug code" style="
    display: none;
    position: fixed;
    top: 70%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 9999;
    font-size: 20px;
    padding: 8px 16px;
    background-color: #111;
    color: #0f0;
    border: 2px solid #0f0;
    border-radius: 6px;
    text-align: center;
">



<script>

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

function updateCanvasDimensions() {
	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;
}

window.onblur = function() {
	paused = true;
};

//Customization variables:
//--------------------------------------------------------------------

//Colors:
let squareMainColor = "#ffffff";
let squareBorderColor = "#808080";

const obstacleColors = {
	0: "#ff0000",
	25: "#ffff00",
	50: "#00ff00",
	100: "#00ffff",
	125: "#0000ff",
	150: "#ff00ff"
};

//Square dimensions:
let squareSizeX = 30;
let squareSizeY = 30;

//Player:
let playerSpeed = 6000;
let dashCooldown = 5; // seconds
const dashDistance = 400;


//Environment:
let drag = 0.1;

//Extras:
let frameMultiplier = 1;

//Debug Codes:
let playerInvincible = false;

const debugCodes = {
	"HELP": () => alert("This is for the developer, not you"),
  	"GOD": () => playerInvincible = true,
  	"CLEAR": () => obstacles.length = 0,
  	"SPEED": () => playerSpeed *= 1.5,
  	"SCORE": (num) => {
		score = Number(num);
	},
	"HIGHSCORE": (num) => {
		highscore = Number(num);
	},
	"RUSH": () => frameMultiplier = 2,
	"ICE": () => drag = 0,
	"INFDASH": () => dashCooldown = 0,
	"HIDEOBS": () => obsHidden = true
};

let debugUsed = false;

let obsHidden = false;

//--------------------------------------------------------------------
let gameOver = false;
let score = 0;
let paused = false;

let highscore = localStorage.getItem("highscore") ?? 0;

let dashTimer = 0;
let canDash = true;

var dashSound = new Audio("/audio/whoosh.mp3");
	
let xSpeed = 0;
let ySpeed = 0;

var squareX = 0;
var squareY = 0;


let wDown = false;
let sDown = false;
let aDown = false;
let dDown = false;

document.addEventListener('keydown', (event) => {
    if(event.code === "KeyW") {
        wDown = true;
    }
    if(event.code === "KeyS") {
        sDown = true;
    }
    if(event.code === "KeyA") {
        aDown = true;
    }
    if(event.code === "KeyD") {
        dDown = true;
    }
});

document.addEventListener('keyup', (event) => {
    if(event.code === "KeyW") {
        wDown = false;
    }
    if(event.code === "KeyS") {
        sDown = false;
    }
    if(event.code === "KeyA") {
        aDown = false;
    }
    if(event.code === "KeyD") {
        dDown = false;
    }
});

//Pause
document.addEventListener('keydown', (event) => {
    if (event.code === "Escape") {
        paused = !paused;
        if (!paused) {
            lastTimestamp = performance.now();
        }

        //Toggle debug UI
        document.getElementById("debugCodeInput").style.display = paused ? "block" : "none";
    }
});


//Dash
document.addEventListener('keydown', (event) => {
    if (event.code === "Space" && canDash && !paused && !gameOver) {
        performDash();
        canDash = false;
        dashTimer = 0;
    }
});

//Auto submit debug code on enter
document.getElementById("debugCodeInput").addEventListener("keydown", (e) => {
  if (e.key === "Enter") {
    submitDebugCode();
  }
});


function submitDebugCode() {
  const rawInput = document.getElementById("debugCodeInput").value;
  const lines = rawInput.split("\n").map(line => line.trim()).filter(Boolean);

  for (let line of lines) {
    const parts = line.split(/\s+/); // split by whitespace
    const command = parts[0].toUpperCase();
    const args = parts.slice(1);

    const handler = debugCodes[command];

    if (!handler) {
      console.warn(`Unknown devcode: ${command}`);
      continue;
    }
	  
	debugUsed = true;
    //If the handler expects arguments, pass them
    if (handler.length > 0) {
      handler(...args);
    } else {
      handler(); //legacy devcode
    }
  }

  document.getElementById("debugCodeInput").value = "";
}



function getOffscreenSpawn(size) {
    const edge = Math.floor(Math.random() * 4); //0=top, 1=right, 2=bottom, 3=left
    let x, y;

    switch (edge) {
        case 0: // top
            x = Math.random() * canvas.width;
            y = -size;
            break;
        case 1: // right
            x = canvas.width + size;
            y = Math.random() * canvas.height;
            break;
        case 2: // bottom
            x = Math.random() * canvas.width;
            y = canvas.height + size;
            break;
        case 3: // left
            x = -size;
            y = Math.random() * canvas.height;
            break;
    }
    return { x, y };
}

function getAngleToPlayer(fromX, fromY) {
    const dx = squareX + squareSizeX / 2 - fromX;
    const dy = squareY + squareSizeY / 2 - fromY;
    return Math.atan2(dy, dx) * (180 / Math.PI); // degrees
}

function getObstacleColor(score) {
	//Return black if hidden
	if(obsHidden) {
		return "#000000";
	}
  	const keys = Object.keys(obstacleColors)
    	.map(Number)
    	.sort((a, b) => b - a); //highest to lowest
	
  	for (let key of keys) {
    	if (score >= key) {
      		return obstacleColors[key];
    	}
  	}
  	return null;
}


class Obstacle {
    constructor(x, y, speed, angleDeg, size = 20) {
        this.x = x;
        this.y = y;
        this.speed = speed; // pixels per second
        this.angle = angleDeg * (Math.PI / 180); // convert to radians
        this.size = size;
    }

    update(deltaTime) {
        this.x += Math.cos(this.angle) * this.speed * deltaTime;
        this.y += Math.sin(this.angle) * this.speed * deltaTime;
    }

    draw(ctx) {
        ctx.fillStyle = getObstacleColor(Math.floor(score)); //Obstacle color based on score
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
    }
}


//Global array to hold obstacles
const obstacles = [];

function spawnObstacle(x, y, speed, angleDeg, size = 20) {
    obstacles.push(new Obstacle(x, y, speed, angleDeg, size));
}

let obstacleTimer = 0;
let obstacleInterval = 1.5; // seconds
let obstacleSpeedMultiplier = 1;

function updateObstacles(deltaTime) {
    obstacleTimer += deltaTime;
    if (obstacleTimer >= obstacleInterval) {
        obstacleTimer = 0;

        const size = Math.random() * (100 - 20) + 20; //Random size between 20 and 100
        const speed = 150 * obstacleSpeedMultiplier + Math.random() * (50 - -50) + -50; // 150 + speed multiplier plus or minus 50

        // Spawn outside screen
        const spawn = getOffscreenSpawn(size);

        // Aim toward player
        const angle = getAngleToPlayer(spawn.x, spawn.y);

        // Create obstacle
        spawnObstacle(spawn.x, spawn.y, speed, angle, size);
		
		// +1% Obstacle speed every spawn
		obstacleSpeedMultiplier *= 1.01;
		// -1% Spawn cooldown every spawn
		obstacleInterval *= 0.99;
    }

    // Update, draw, and check collision
    for (let obs of obstacles) {
        obs.update(deltaTime);
        obs.draw(ctx);

        if (!playerInvincible && rectCircleCollides(squareX, squareY, squareSizeX, squareSizeY, obs.x, obs.y, obs.size)) {
  			die();
		}
    }
}


//Enemy collision complicated stuff
function rectCircleCollides(rx, ry, rw, rh, cx, cy, cr) {
    const closestX = Math.max(rx, Math.min(cx, rx + rw));
    const closestY = Math.max(ry, Math.min(cy, ry + rh));
    const dx = cx - closestX;
    const dy = cy - closestY;
    return (dx * dx + dy * dy) < (cr * cr);
}


let lastTimestamp = 0;
let deltaTime;

function nextFrame(currentTimestamp) {
	//Every frame:
	deltaTime = (currentTimestamp - lastTimestamp) / 1000;
    lastTimestamp = currentTimestamp;

	clearScreen();
	if (!gameOver && !paused) {
        for (let i = 0; i < frameMultiplier; i++) {
            moveSquare();
			//Dash
			if (!canDash) {
    			dashTimer += deltaTime;
    			if (dashTimer >= dashCooldown) {
        			canDash = true;
    			}
			}
            updateObstacles(deltaTime);
			score += deltaTime;
        }
	}
	drawSquare();
	drawUI();
	
	requestAnimationFrame(nextFrame);
}

function drawSquare() {
    ctx.beginPath();
    
	ctx.fillStyle = squareMainColor;
	ctx.strokeStyle = squareBorderColor;
	ctx.lineWidth = "8";
    
	ctx.rect(squareX, squareY, squareSizeX, squareSizeY);
	ctx.stroke();
	ctx.fill();
}

function onCollision(direction) {
	if(direction === "left") xSpeed = Math.abs(xSpeed);
	if(direction === "right") xSpeed = -Math.abs(xSpeed);
	if(direction === "top") ySpeed = Math.abs(ySpeed);
	if(direction === "bottom") ySpeed = -Math.abs(ySpeed);
	
	console.log("Collided " + direction);
}

function moveSquare() {
	const newX = squareX + xSpeed * deltaTime;
    const newY = squareY + ySpeed * deltaTime;

    if(wDown) ySpeed -= playerSpeed * deltaTime;
	if(sDown) ySpeed += playerSpeed * deltaTime;
	if(aDown) xSpeed -= playerSpeed * deltaTime;
	if(dDown) xSpeed += playerSpeed * deltaTime;

	//Acceleration:
    const damping = Math.pow(1 - drag, deltaTime * 60); // normalize to 60fps
	xSpeed *= damping;
	ySpeed *= damping;


    // Check if any part of the square goes beyond the canvas edges
	//Left
	if(newX < 0) onCollision("left"); 
	//Right
	if(newX + squareSizeX > canvas.width) onCollision("right");
	//Top
	if(newY < 0) onCollision("top");
	//Bottom
	if(newY + squareSizeY > canvas.height) onCollision("bottom");
    
	squareX = newX;
	squareY = newY;
}

function drawUI() {
    //Score text
    ctx.fillStyle = "#40ff90";
    ctx.font = "24px monospace";
    ctx.textAlign = "left";
    ctx.fillText(`Score: ${Math.floor(score)}`, 20, 40);

	//Highscore text
    ctx.fillStyle = "#40ff90";
    ctx.font = "24px monospace";
    ctx.textAlign = "right";
    ctx.fillText(`Highscore: ${Math.floor(highscore)}`, canvas.width - 20, 40);

    //Pause screen
    if (paused) {
        ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = "#ffffff";
        ctx.font = "48px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("Paused", canvas.width / 2, canvas.height / 2);
    }

    //Death screen
    if (gameOver) {
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = "#ff4040";
        ctx.font = "bold 64px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("YOU DIED", canvas.width / 2, canvas.height / 2);
		//New highscore text:
		if(score >= highscore) {
			ctx.fillStyle = "#ffff00";
        	ctx.font = "bold 48px sans-serif";
        	ctx.textAlign = "center";
        	ctx.fillText("New Highscore!", canvas.width / 2, canvas.height / 3);
		}
    }
	
	//Dash bar
	if (!canDash) {
    	const barWidth = 200;
    	const barHeight = 10;
    	const x = canvas.width / 2 - barWidth / 2;
    	const y = canvas.height - 30;
	
    	const progress = dashTimer / dashCooldown;
	
    	ctx.fillStyle = "#444";
    	ctx.fillRect(x, y, barWidth, barHeight);
	
    	ctx.fillStyle = "#40ff90";
    	ctx.fillRect(x, y, barWidth * progress, barHeight);
	}
}

function performDash() {
    if (wDown) squareY -= dashDistance;
    if (sDown) squareY += dashDistance;
    if (aDown) squareX -= dashDistance;
    if (dDown) squareX += dashDistance;

	xSpeed *= 5;
	ySpeed *= 5;

    // Clamp to canvas bounds
    squareX = Math.max(0, Math.min(canvas.width - squareSizeX, squareX));
    squareY = Math.max(0, Math.min(canvas.height - squareSizeY, squareY));
	dashSound.play();
}

function doHighscore() {
	if(score > highscore && !debugUsed) {
		localStorage.setItem("highscore", score);
		highscore = score;
	}
}

function die() {
	console.log("Dead!");
	gameOver = true;
	//Check/set highscore
	doHighscore();
	//Show respawn button
	document.getElementById("respawnBtn").style.display = "block";
}

function respawn() {
	location.reload();
}

function clearScreen() {
	ctx.clearRect(0, 0, canvas.width, canvas.height);
	//that doesn't work for some reason but this does:
	canvas.width = canvas.width;
}

function updateHighscore() {
	//make later
}

updateCanvasDimensions();
//Starting positions:
squareX = canvas.width/2 - squareSizeX/2;
squareY = canvas.height/2 - squareSizeY/2;

//Start the loop
requestAnimationFrame(nextFrame);
</script>
</body>
</html>
