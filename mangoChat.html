<!DOCTYPE html>
<html>
<head>
    <title>Mango Chat</title>

    <!-- LZString for compression -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>

    <!-- QR Code generator -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

    <!-- QR Code scanner ZXing -->
    <script src="https://unpkg.com/@zxing/library@latest"></script>

    <style>
        body {
            font-family: sans-serif;
            max-width: 1000px;
            margin: 20px auto;
        }

        .hidden {
            display: none;
        }

        textarea,
        input {
            width: 100%;
        }

        button {
            margin-top: 6px;
        }

        #chatBox {
            border: 1px solid #ccc;
            padding: 10px;
            height: 250px;
            overflow-y: auto;
            white-space: pre-wrap;
            background: #fafafa;
        }

        .flex {
            display: flex;
            gap: 20px;
        }

        .qrBox {
            min-width: 150px;
        }

        #hostQR canvas,
        #hostQR img,
        #answerQR canvas,
        #answerQR img {
            width: 512px;
            height: 512px;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        /* Dark popup scanner overlay */
        #scannerOverlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        #scannerModal {
            background: #111;
            border-radius: 8px;
            padding: 16px;
            color: #fff;
            max-width: 420px;
            width: 90%;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            text-align: center;
        }

        #scannerVideo {
            width: 100%;
            max-height: 260px;
            background: #000;
            border-radius: 4px;
        }

        #scannerCloseBtn {
            margin-top: 10px;
            padding: 6px 12px;
        }
    </style>
</head>
<body>
<h1>Mango Chat</h1>

<div id="setup">
    <button onclick="startHost()">Host</button>
    <button onclick="startJoin()">Join</button>
</div>

<!-- HOST UI -->
<div id="hostUI" class="hidden">
    <h3>Share this join code:</h3>

    <div class="flex">
        <div style="flex:1;">
            <div id="joinCode" style="font-size:10px; font-weight:bold; word-break:break-all;"></div>
            <button onclick="copyJoinCode()">Copy Code</button>
        </div>

        <div class="qrBox">
            <div id="hostQR"></div>
        </div>
    </div>

    <h3>Paste encoded answer from client:</h3>
    <textarea id="hostAnswer" rows="4"></textarea>
    <button onclick="pasteHostAnswer()">Paste Answer</button>
    <button onclick="openScanner('hostAnswer')">Scan Answer QR</button>
    <button onclick="applyHostAnswer()">Connect</button>
</div>

<!-- JOIN UI -->
<div id="joinUI" class="hidden">
    <h3>Enter join code:</h3>

    <div class="flex">
        <div style="flex:1;">
            <input id="codeInput" />
            <button onclick="pasteJoinCode()">Paste Code</button>
            <button onclick="openScanner('codeInput')">Scan Join Code QR</button>
            <button onclick="joinWithCode()">Submit Code</button>
        </div>
    </div>

    <h3>Send this encoded answer back to host:</h3>

    <div class="flex">
        <div style="flex:1;">
            <textarea id="answerOut" rows="4"></textarea>
            <button onclick="copyAnswer()">Copy Answer</button>
        </div>

        <div class="qrBox">
            <div id="answerQR"></div>
        </div>
    </div>
</div>

<!-- CHAT UI -->
<div id="app" class="hidden">
    <h2>Chat</h2>

    <div id="chatBox"></div>

    <input id="chatInput" placeholder="Type a message..." />
    <button id="sendBtn" onclick="sendMessage()" disabled>Send</button>

    <p id="status"></p>
</div>

<!-- Dark popup QR scanner -->
<div id="scannerOverlay">
    <div id="scannerModal">
        <h3>Scan QR Code</h3>
        <video id="scannerVideo" autoplay playsinline></video>
        <canvas id="scannerCanvas" class="hidden"></canvas>
        <div>
            <button id="scannerCloseBtn" onclick="closeScanner()">Close</button>
        </div>
    </div>
</div>
<script>
    let pc;
    let channel;
    let isHost = false;
    let messages = [];
    let messageLimit = 10;
    let pendingAnswer = null; // joiner waits for ICE to finish

    const statusEl = document.getElementById("status");

    // Scanner state
    let scanTargetId = null;
    let scannerStream = null;
    let scanning = false;

    // URL-safe Base64 helpers
    function toUrlSafe(b64) {
        return b64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
    }
    function fromUrlSafe(str) {
        str = str.replace(/-/g, "+").replace(/_/g, "/");
        while (str.length % 4) str += "=";
        return str;
    }

    function renderChat() {
        chatBox.textContent = messages
            .map(m => `[${m.from}] > ${m.text}`)
            .join("\n");
        chatBox.scrollTop = chatBox.scrollHeight;
    }

    function makeQR(elementId, text) {
        const el = document.getElementById(elementId);
        if (!el) return;

        el.innerHTML = "";

        // Step 1: create a temporary QR to read module count
        const temp = new QRCode(el, {
            text,
            width: 1,
            height: 1,
            correctLevel: QRCode.CorrectLevel.L,
            margin: 8
        });

        // Wait for QR to render
        setTimeout(() => {
            const canvas = el.querySelector("canvas");
            if (!canvas) return;

            // Extract module count from qrcode.js internals
            const moduleCount = temp._oQRCode.getModuleCount();

            // Choose an integer module size
            const moduleSize = 16;
            const finalSize = moduleCount * moduleSize;

            // Clear and re-render at perfect integer resolution
            el.innerHTML = "";
            new QRCode(el, {
                text,
                width: finalSize,
                height: finalSize,
                correctLevel: QRCode.CorrectLevel.L,
                margin: 8 // default is 4
            });

            // Force crisp rendering
            const finalCanvas = el.querySelector("canvas");
            if (finalCanvas) {
                finalCanvas.style.width = finalSize + "px";
                finalCanvas.style.height = finalSize + "px";
                finalCanvas.style.imageRendering = "pixelated";
            }
        }, 0);
    }

    async function startHost() {
        isHost = true;

        setup.style.display = "none";
        hostUI.style.display = "block"; // show UI first

        pc = new RTCPeerConnection({
            iceServers: [],               // no STUN, no TURN
            iceTransportPolicy: "all"     // allow host candidates
        });

        channel = pc.createDataChannel("chat");
        setupChannel();

        pc.onicecandidate = e => {
            if (!e.candidate) {
                const offer = pc.localDescription.sdp;
                const compressed = LZString.compressToBase64(offer);
                const urlSafe = toUrlSafe(compressed);

                joinCode.textContent = urlSafe;
                makeQR("hostQR", urlSafe);
            }
        };

        pc.oniceconnectionstatechange = () => {
            console.log("Host ICE state:", pc.iceConnectionState);
            statusEl.textContent = "Status: " + pc.iceConnectionState;
        };

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
    }

    async function applyHostAnswer() {
        const encoded = hostAnswer.value.trim();
        const b64 = fromUrlSafe(encoded);
        const sdp = LZString.decompressFromBase64(b64);

        await pc.setRemoteDescription({
            type: "answer",
            sdp
        });

        hostUI.style.display = "none";
        app.style.display = "block";
        statusEl.textContent = "Waiting for connection...";
    }

    function startJoin() {
        isHost = false;

        pc = new RTCPeerConnection({
            iceServers: [],               // no STUN, no TURN
            iceTransportPolicy: "all"     // allow host candidates
        });

        pc.ondatachannel = e => {
            channel = e.channel;
            setupChannel();
        };

        pc.onicecandidate = e => {
            // When ICE gathering is done and we have marked that an answer is pending,
            // serialize the full SDP (with candidates) into the QR.
            if (!e.candidate && pendingAnswer) {
                const fullAnswerSDP = pc.localDescription.sdp;
                const compressed = LZString.compressToBase64(fullAnswerSDP);
                const urlSafe = toUrlSafe(compressed);

                answerOut.value = urlSafe;
                makeQR("answerQR", urlSafe);

                pendingAnswer = null;
            }
        };

        pc.oniceconnectionstatechange = () => {
            console.log("Joiner ICE state:", pc.iceConnectionState);
            statusEl.textContent = "Status: " + pc.iceConnectionState;
        };

        setup.style.display = "none";
        joinUI.style.display = "block";
    }

    async function joinWithCode() {
        const encoded = codeInput.value.trim();
        const b64 = fromUrlSafe(encoded);
        const offerSDP = LZString.decompressFromBase64(b64);

        await pc.setRemoteDescription({
            type: "offer",
            sdp: offerSDP
        });

        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);

        // Do NOT build the QR yet; wait for ICE to finish.
        pendingAnswer = true;
        statusEl.textContent = "Status: gathering ICE...";
    }

    function setupChannel() {
        channel.onopen = () => {
            joinUI.style.display = "none";
            app.style.display = "block";
            statusEl.textContent = "Connected!";
            sendBtn.disabled = false;
        };

        channel.onmessage = e => {
            const msg = JSON.parse(e.data);

            if (msg.type === "msg") {
                messages.push(msg);
                messages = messages.slice(-messageLimit);
                renderChat();
            }
        };
    }

    function sendMessage() {
        if (!channel || channel.readyState !== "open") return;

        const text = chatInput.value.trim();
        if (!text) return;

        const msg = {
            type: "msg",
            from: isHost ? "HOST" : "CLIENT",
            text
        };

        messages.push(msg);
        messages = messages.slice(-messageLimit);
        renderChat();

        channel.send(JSON.stringify(msg));

        chatInput.value = "";
    }

    // Clipboard helpers
    async function copyJoinCode() {
        await navigator.clipboard.writeText(joinCode.textContent);
        alert("Copied!");
    }

    async function pasteHostAnswer() {
        const text = await navigator.clipboard.readText();
        hostAnswer.value = text;
    }

    async function pasteJoinCode() {
        const text = await navigator.clipboard.readText();
        codeInput.value = text;
    }

    async function copyAnswer() {
        await navigator.clipboard.writeText(answerOut.value);
        alert("Copied!");
    }

    // QR scanner popup logic (ZXing)
    let codeReader = new ZXing.BrowserQRCodeReader();

    async function openScanner(targetId) {
        scanTargetId = targetId;

        const overlay = document.getElementById("scannerOverlay");
        const video = document.getElementById("scannerVideo");

        overlay.style.display = "flex";

        try {
            await codeReader.decodeFromVideoDevice(
                null,            // auto-select camera
                "scannerVideo",  // your <video> element ID
                (result, err) => {
                    if (result) {
                        const target = document.getElementById(scanTargetId);
                        if (target) target.value = result.text;
                        closeScanner();
                    }
                }
            );
        } catch (err) {
            alert("Unable to access camera: " + err.message);
            closeScanner();
        }
    }

    function closeScanner() {
        scanning = false;

        const overlay = document.getElementById("scannerOverlay");
        const video = document.getElementById("scannerVideo");

        overlay.style.display = "none";

        codeReader.reset();

        if (scannerStream) {
            scannerStream.getTracks().forEach(t => t.stop());
            scannerStream = null;
        }

        video.srcObject = null;
    }
</script>    
</body>
</html>