<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Game of Life</title>
  <style>
    body {
      display: flex;
      flex-flow: row wrap;
      gap: 15px;
      align-items: center;
      justify-content: center;
    }
    canvas {
      border: 1px solid black;
    }
    #menu {
      display: flex;
      flex-flow: column nowrap;
      padding: 5px;
      border: 2px solid black;
    }
    #menu > .row {
      display: flex;
      flex-flow: row nowrap;
      padding: 5px;
      gap: 5px;
    }
    #menu > button {
      flex-grow: 1;
    }
  </style>
</head>
<body>
  <canvas id="lifeCanvas" width="500" height="500"></canvas><br>
  <div id="menu">
    <div id="searchIndicator" style="display:none; font-weight:bold;">Searching for reverseâ€¦</div>
    <div id="attemptCounter" style="font-family:monospace;"></div>
    <div class="row">
      <button id="runBtn">Run</button>
      <button id="stopBtn">Stop</button>
      <button id="restartBtn">Restart</button>
    </div>
    <div class="row">
      <button id="forwardBtn">Forward</button>
      <button id="backwardBtn">Backward</button>
    </div>
    <div class="row">
      <button id="increaseGridBtn">Increase Grid Size</button>
      <button id="decreaseGridBtn">Decrease Grid Size</button>
    </div>
    <div class="row">
      <button id="startReverseBtn">Start Reverse Search</button>
      <button id="stopReverseBtn">Stop Reverse Search</button>
    </div>
    <div class="row">
      <button id="exportBtn">Export Grid</button>
      <button id="importBtn">Import Grid</button>
    </div>
  </div>
<script>
const canvas = document.getElementById("lifeCanvas");
const ctx = canvas.getContext("2d");

let gridSize = 25;
let cellSize = canvas.width / gridSize;

let running = false;
let intervalId = null;
let bruteForceRunning = false;
let bruteForceInterval = null;

const initialGrid = Array(gridSize).fill().map(() => Array(gridSize).fill(0));
initialGrid[1][2] = 1;
initialGrid[2][3] = 1;
initialGrid[3][1] = 1;
initialGrid[3][2] = 1;
initialGrid[3][3] = 1;

let currentGrid = initialGrid.map(row => row.slice());
let history = [currentGrid];
let currentGen = 0;

function drawGrid(grid) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (let row = 0; row < grid.length; row++) {
    for (let column = 0; column < grid[row].length; column++) {
      if (grid[row][column] === 1) {
        ctx.fillRect(column * cellSize, row * cellSize, cellSize, cellSize);
      }
    }
  }
}

function getNextState(state, neighbors) {
  return state === 1 ? (neighbors === 2 || neighbors === 3 ? 1 : 0) : (neighbors === 3 ? 1 : 0);
}

function getNeighborsSum(grid, row, col) {
  const numRows = grid.length;
  const numCols = grid[0].length;
  let sum = 0;
  for (let i = -1; i <= 1; i++) {
    for (let j = -1; j <= 1; j++) {
      if (i === 0 && j === 0) continue;
      const wrappedRow = (row + i + numRows) % numRows;
      const wrappedCol = (col + j + numCols) % numCols;
      sum += grid[wrappedRow][wrappedCol];
    }
  }
  return sum;
}

function updateGrid() {
  const newGrid = [];
  for (let row = 0; row < currentGrid.length; row++) {
    newGrid[row] = [];
    for (let col = 0; col < currentGrid[row].length; col++) {
      const neighbors = getNeighborsSum(currentGrid, row, col);
      newGrid[row][col] = getNextState(currentGrid[row][col], neighbors);
    }
  }
  return newGrid;
}

function reverseGrid() {
  if (currentGen > 0) {
    currentGen--;
    currentGrid = history[currentGen].map(row => row.slice());
  }
}

function getInfluenceZone(grid) {
  const zone = new Set();
  for (let row = 0; row < gridSize; row++) {
    for (let col = 0; col < gridSize; col++) {
      if (grid[row][col] === 1) {
        for (let dr = -1; dr <= 1; dr++) {
          for (let dc = -1; dc <= 1; dc++) {
            const r = (row + dr + gridSize) % gridSize;
            const c = (col + dc + gridSize) % gridSize;
            zone.add(`${r},${c}`);
          }
        }
      }
    }
  }
  return zone;
}

function updateGridFrom(grid) {
  const newGrid = [];
  for (let row = 0; row < grid.length; row++) {
    newGrid[row] = [];
    for (let col = 0; col < grid[row].length; col++) {
      const neighbors = getNeighborsSum(grid, row, col);
      newGrid[row][col] = getNextState(grid[row][col], neighbors);
    }
  }
  return newGrid;
}

function gridsEqual(a, b) {
  for (let row = 0; row < gridSize; row++) {
    for (let col = 0; col < gridSize; col++) {
      if (a[row][col] !== b[row][col]) return false;
    }
  }
  return true;
}

function serializeGrid(grid) {
  return grid.map(row => row.join("")).join("|");
}

function exportGridAsCoords(grid) {
  const coords = [];
  coords.push(gridSize);
  for (let row = 0; row < grid.length; row++) {
    for (let col = 0; col < grid[row].length; col++) {
      if (grid[row][col] === 1) {
        coords.push([row, col]);
      }
    }
  }
  
  const json = JSON.stringify(coords);
  navigator.clipboard.writeText(json).then(() => {
    alert("Grid copied as coordinates!");
  });
}

function importGridFromCoords(json) {
  try {
    const coords = JSON.parse(json);
    const newGrid = Array(gridSize).fill().map(() => Array(gridSize).fill(0));

    resizeGrid(coords[0]);
    for(let coord = 1; coord < coords.length; coord++) {
      const row = coords[coord][0];
      const col = coords[coord][1];
      if (row >= 0 && row < gridSize && col >= 0 && col < gridSize) {
        newGrid[row][col] = 1;
      }
    }
    currentGrid = newGrid;
    history = [newGrid.map(row => row.slice())];
    currentGen = 0;
    drawGrid(currentGrid);
  } catch (e) {
    alert("Invalid coordinate format.");
  }
}

function resizeGrid(newSize) {
  if (newSize < 1) {
    alert("Grid size must be greater than 0");
    return;
  }

  const newGrid = Array(newSize).fill().map(() => Array(newSize).fill(0));
  for (let row = 0; row < Math.min(gridSize, newSize); row++) {
    for (let col = 0; col < Math.min(gridSize, newSize); col++) {
      newGrid[row][col] = currentGrid[row][col];
    }
  }

  gridSize = newSize;
  cellSize = canvas.width / gridSize;
  currentGrid = newGrid;
  history = [newGrid.map(row => row.slice())];
  currentGen = 0;
  drawGrid(currentGrid);
}

function startBruteForceReverse(targetGrid) {
  const influenceZone = getInfluenceZone(targetGrid);
  const visited = new Set();
  const counter = document.getElementById("attemptCounter");
  let attempt = 0;
  const batchSize = 5000; // Number of attempts per tick

  bruteForceRunning = true;

  bruteForceInterval = setInterval(() => {
    if (!bruteForceRunning) {
      clearInterval(bruteForceInterval);
      counter.textContent = `Stopped at attempt ${attempt}`;
      return;
    }

    for (let i = 0; i < batchSize; i++) {
      attempt++;
      const candidate = Array(gridSize).fill().map(() => Array(gridSize).fill(0));
      for (const key of influenceZone) {
        const [r, c] = key.split(',').map(Number);
        candidate[r][c] = Math.random() < 0.5 ? 1 : 0;
      }

      const key = serializeGrid(candidate);
      if (visited.has(key)) continue;
      visited.add(key);

      const evolved = updateGridFrom(candidate);
      if (gridsEqual(evolved, targetGrid)) {
        bruteForceRunning = false;
        clearInterval(bruteForceInterval);
        currentGrid = candidate;
        history = [currentGrid.map(row => row.slice())];
        currentGen = 0;
        drawGrid(currentGrid);
        counter.textContent = `Found match at attempt ${attempt}`;
        return;
      }
    }

    if (attempt % 1000 === 0) {
      counter.textContent = `Attempt ${attempt}`;
    }
  }, 0);
}

function stopBruteForceReverse() {
  bruteForceRunning = false;
  clearInterval(bruteForceInterval);
}

document.getElementById("forwardBtn").addEventListener("click", function () {
  history.push(currentGrid.map(row => row.slice()));
  currentGrid = updateGrid();
  currentGen = history.length;
  drawGrid(currentGrid);
});

document.getElementById("backwardBtn").addEventListener("click", function () {
  reverseGrid();
  drawGrid(currentGrid);
});

document.getElementById("startReverseBtn").addEventListener("click", () => {
  document.getElementById("searchIndicator").style.display = "block";
  startBruteForceReverse(currentGrid);
});

document.getElementById("stopReverseBtn").addEventListener("click", () => {
  document.getElementById("searchIndicator").style.display = "none";
  stopBruteForceReverse();
});

document.getElementById("increaseGridBtn").addEventListener("click", () => {
  resizeGrid(gridSize + 1);
  alert(gridSize);
});

document.getElementById("decreaseGridBtn").addEventListener("click", () => {
  resizeGrid(gridSize - 1);
  alert(gridSize);
});

document.getElementById("exportBtn").addEventListener("click", () => {
  exportGridAsCoords(currentGrid);
});

document.getElementById("importBtn").addEventListener("click", () => {
  const input = prompt("Paste coordinate JSON:");
  if (input) importGridFromCoords(input);
});

document.getElementById("runBtn").addEventListener("click", function () {
  if (!running) {
    running = true;
    intervalId = setInterval(() => {
      history.push(currentGrid.map(row => row.slice()));
      currentGrid = updateGrid();
      currentGen = history.length;
      drawGrid(currentGrid);
    }, 200);
  }
});

document.getElementById("stopBtn").addEventListener("click", function () {
  running = false;
  clearInterval(intervalId);
});

document.getElementById("restartBtn").addEventListener("click", function () {
  running = false;
  clearInterval(intervalId);
  currentGrid = history[0].map(row => row.slice());
  history = [currentGrid];
  currentGen = 0;
  drawGrid(currentGrid);
});

canvas.addEventListener("click", function (event) {
  const rect = canvas.getBoundingClientRect();
  const x = event.clientX - rect.left;
  const y = event.clientY - rect.top;
  const col = Math.floor(x / cellSize);
  const row = Math.floor(y / cellSize);
  currentGrid[row][col] = currentGrid[row][col] === 1 ? 0 : 1;
  history = [currentGrid.map(row => row.slice())];
  currentGen = 0;
  drawGrid(currentGrid);
});

window.onload = function () {
  currentGrid = initialGrid.map(row => row.slice());
  history = [currentGrid];
  currentGen = 0;
  drawGrid(currentGrid);
};
</script>
</body>
</html>
