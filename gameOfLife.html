<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Game of Life</title>
  <style>
    body {
      display: flex;
      flex-flow: row wrap;
      gap: 15px;
      align-items: center;
      justify-content: center;
    }
    canvas {
      border: 1px solid black;
    }
    #menu {
      display: flex;
      flex-flow: column nowrap;
      padding: 15px;

      border: 2px solid black;
    }
    #menu > .row {
      dsplay: flex;
      flex-flow: row nowrap;
      padding: 15px;
    }
    #menu > button {
      margin: 15px;
      flex-grow: 1;
    }
  </style>
</head>
<body>
  <canvas id="lifeCanvas" width="500" height="500"></canvas><br>
  <div id="menu">
    <div class="row">
      <button id="runBtn">Run</button>
      <button id="stopBtn">Stop</button>
      <button id="restartBtn">Restart</button>
    </div>
    <div class="row">
      <button id="forwardBtn">Forward</button>
      <button id="backwardBtn">Backward</button>
    </div>
    <div class="row">
      <button id="exportBtn">Export Grid</button>
      <button id="importBtn">Import Grid</button>
    </div>
  </div>
<script>
const canvas = document.getElementById("lifeCanvas");
const ctx = canvas.getContext("2d");

const gridSize = 25;
const cellSize = canvas.width / gridSize;

let running = false;
let intervalId = null;

// Starting grid (glider)
const initialGrid = Array(gridSize).fill().map(() => Array(gridSize).fill(0));
initialGrid[1][2] = 1;
initialGrid[2][3] = 1;
initialGrid[3][1] = 1;
initialGrid[3][2] = 1;
initialGrid[3][3] = 1;

let currentGrid = initialGrid.map(row => row.slice());
let history = [currentGrid];
let currentGen = 0;

function drawGrid(grid) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (let row = 0; row < grid.length; row++) {
    for (let column = 0; column < grid[row].length; column++) {
      if (grid[row][column] === 1) {
        ctx.fillRect(column * cellSize, row * cellSize, cellSize, cellSize);
      }
    }
  }
}

function getNextState(state, neighbors) {
  if (state === 1) {
    return neighbors === 2 || neighbors === 3 ? 1 : 0;
  } else {
    return neighbors === 3 ? 1 : 0;
  }
}

function getNeighborsSum(grid, row, col) {
  const numRows = grid.length;
  const numCols = grid[0].length;
  let sum = 0;

  for (let i = -1; i <= 1; i++) {
    for (let j = -1; j <= 1; j++) {
      if (i === 0 && j === 0) continue;
      const wrappedRow = (row + i + numRows) % numRows;
      const wrappedCol = (col + j + numCols) % numCols;
      sum += grid[wrappedRow][wrappedCol];
    }
  }

  return sum;
}

function updateGrid() {
  const newGrid = [];
  for (let row = 0; row < currentGrid.length; row++) {
    newGrid[row] = [];
    for (let col = 0; col < currentGrid[row].length; col++) {
      const neighbors = getNeighborsSum(currentGrid, row, col);
      newGrid[row][col] = getNextState(currentGrid[row][col], neighbors);
    }
  }
  currentGrid = newGrid;
}

function reverseGrid() {
  if (currentGen > 0) {
    currentGen--;
    currentGrid = history[currentGen].map(row => row.slice());
  }
}

function exportGridAsCoords(grid) {
  const coords = [];
  for (let row = 0; row < grid.length; row++) {
    for (let col = 0; col < grid[row].length; col++) {
      if (grid[row][col] === 1) {
        coords.push([row, col]);
      }
    }
  }
  const json = JSON.stringify(coords);
  navigator.clipboard.writeText(json).then(() => {
    alert("Grid copied as coordinates!");
  });
}

function importGridFromCoords(json) {
  try {
    const coords = JSON.parse(json);
    const newGrid = Array(gridSize).fill().map(() => Array(gridSize).fill(0));
    coords.forEach(([row, col]) => {
      if (row >= 0 && row < gridSize && col >= 0 && col < gridSize) {
        newGrid[row][col] = 1;
      }
    });
    currentGrid = newGrid;
    history = [newGrid.map(row => row.slice())];
    currentGen = 0;
    drawGrid(currentGrid);
  } catch (e) {
    alert("Invalid coordinate format.");
  }
}


document.getElementById("forwardBtn").addEventListener("click", function () {
  const snapshot = currentGrid.map(row => row.slice()); // Copy before update
  history.push(snapshot);
  currentGen++;
  updateGrid();
  drawGrid(currentGrid);
});


document.getElementById("backwardBtn").addEventListener("click", function () {
  reverseGrid();
  drawGrid(currentGrid);
});

document.getElementById("exportBtn").addEventListener("click", () => {
  exportGridAsCoords(currentGrid);
});

document.getElementById("importBtn").addEventListener("click", () => {
  const input = prompt("Paste coordinate JSON:");
  if (input) importGridFromCoords(input);
});

document.getElementById("runBtn").addEventListener("click", function () {
  if (!running) {
    running = true;
    intervalId = setInterval(() => {
      const snapshot = currentGrid.map(row => row.slice());
      history.push(snapshot);
      currentGen++;
      updateGrid();
      drawGrid(currentGrid);
    }, 200); // speed here
  }
});

document.getElementById("stopBtn").addEventListener("click", function () {
  running = false;
  clearInterval(intervalId);
});

document.getElementById("restartBtn").addEventListener("click", function () {
  running = false;
  clearInterval(intervalId);

  // Go to first state and clear
  currentGrid = history[0];
  history = [currentGrid];
  drawGrid(currentGrid);
});

canvas.addEventListener("click", function (event) {
  const rect = canvas.getBoundingClientRect();
  const x = event.clientX - rect.left;
  const y = event.clientY - rect.top;

  const col = Math.floor(x / cellSize);
  const row = Math.floor(y / cellSize);

  // Toggle the cell
  currentGrid[row][col] = currentGrid[row][col] === 1 ? 0 : 1;
  history = [currentGrid.map(row => row.slice())]; // Clear history
  currentGen = 0;
  drawGrid(currentGrid);
});


window.onload = function () {
  currentGrid = initialGrid.map(row => row.slice());
  history = [currentGrid];
  currentGen = 0;
  drawGrid(currentGrid);
};

</script>
</body>
</html>
