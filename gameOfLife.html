<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Game of Life</title>
  <style>
    body {
      height: 100vh;
      display: flex;
      flex-flow: row wrap;
      gap: 15px;
      align-items: center;
      justify-content: center;
    }
    canvas {
      border: 1px solid black;
    }
    #menu {
      display: flex;
      flex-flow: column nowrap;
      min-width: 500px;
      padding: 5px;
      border: 2px solid black;
    }
    #menu > .row {
      display: flex;
      flex-flow: row nowrap;
      padding: 5px;
      gap: 5px;
    }
    #menu > button {
      flex-grow: 1;
      text-align: center;
    }
  </style>
</head>
<body>
  <canvas id="lifeCanvas" width="500" height="500"></canvas><br>
  <div id="menu">
    <div id="searchIndicator" style="display:none; font-weight:bold;">Searching for reverse…</div>
    <div id="attemptCounter" style="font-family:monospace;"></div>
    <div class="row">
      <button id="runBtn">Run</button>
      <button id="stopBtn">Stop</button>
      <button id="restartBtn">Restart</button>
      <button id="clearBtn">Clear</button>
    </div>
    <div class="row">
      <button id="forwardBtn">Forward</button>
      <button id="backwardBtn">Backward</button>
    </div>
    <div class="row">
      <button id="increaseGridBtn">Increase Grid Size</button>
      <button id="decreaseGridBtn">Decrease Grid Size</button>
    </div>
    <hr>
    <div class="row">
      <button id="startReverseBtn">Start Reverse Search</button>
      <button id="stopReverseBtn">Stop Reverse Search</button>
    </div>
    <div class="row">
      <button id="startGeneticBtn">Start Genetic Reverse Search</button>
      <button id="stopGeneticBtn">Stop Genetic Reverse Search</button>
    </div>
    <hr>
    <div class="row">
      <button id="exportBtn">Export Grid</button>
      <button id="importBtn">Import Grid</button>
    </div>
  </div>
<script>
const canvas = document.getElementById("lifeCanvas");
const ctx = canvas.getContext("2d");

let gridSize = 25;
let cellSize = canvas.width / gridSize;

let running = false;
let intervalId = null;
let bruteForceRunning = false;
let bruteForceInterval = null;

const initialGrid = Array(gridSize).fill().map(() => Array(gridSize).fill(0));
initialGrid[1][2] = 1;
initialGrid[2][3] = 1;
initialGrid[3][1] = 1;
initialGrid[3][2] = 1;
initialGrid[3][3] = 1;

let currentGrid = initialGrid.map(row => row.slice());
let history = [currentGrid];
let currentGen = 0;

function drawGrid(grid) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (let row = 0; row < grid.length; row++) {
    for (let column = 0; column < grid[row].length; column++) {
      if (grid[row][column] === 1) {
        ctx.fillRect(column * cellSize, row * cellSize, cellSize, cellSize);
      }
    }
  }
}

function getNextState(state, neighbors) {
  return state === 1 ? (neighbors === 2 || neighbors === 3 ? 1 : 0) : (neighbors === 3 ? 1 : 0);
}

function getNeighborsSum(grid, row, col) {
  const numRows = grid.length;
  const numCols = grid[0].length;
  let sum = 0;
  for (let i = -1; i <= 1; i++) {
    for (let j = -1; j <= 1; j++) {
      if (i === 0 && j === 0) continue;
      const wrappedRow = (row + i + numRows) % numRows;
      const wrappedCol = (col + j + numCols) % numCols;
      sum += grid[wrappedRow][wrappedCol];
    }
  }
  return sum;
}

function updateGrid() {
  const newGrid = [];
  for (let row = 0; row < currentGrid.length; row++) {
    newGrid[row] = [];
    for (let col = 0; col < currentGrid[row].length; col++) {
      const neighbors = getNeighborsSum(currentGrid, row, col);
      newGrid[row][col] = getNextState(currentGrid[row][col], neighbors);
    }
  }
  return newGrid;
}

function reverseGrid() {
  if (currentGen > 0) {
    currentGen--;
    currentGrid = history[currentGen].map(row => row.slice());
  }
}

function getInfluenceZone(grid) {
  const zone = new Set();
  for (let row = 0; row < gridSize; row++) {
    for (let col = 0; col < gridSize; col++) {
      if (grid[row][col] === 1) {
        for (let dr = -1; dr <= 1; dr++) {
          for (let dc = -1; dc <= 1; dc++) {
            const r = (row + dr + gridSize) % gridSize;
            const c = (col + dc + gridSize) % gridSize;
            zone.add(`${r},${c}`);
          }
        }
      }
    }
  }
  return zone;
}

function updateGridFrom(grid) {
  const newGrid = [];
  for (let row = 0; row < grid.length; row++) {
    newGrid[row] = [];
    for (let col = 0; col < grid[row].length; col++) {
      const neighbors = getNeighborsSum(grid, row, col);
      newGrid[row][col] = getNextState(grid[row][col], neighbors);
    }
  }
  return newGrid;
}

function gridsEqual(a, b) {
  for (let row = 0; row < gridSize; row++) {
    for (let col = 0; col < gridSize; col++) {
      if (a[row][col] !== b[row][col]) return false;
    }
  }
  return true;
}

function serializeGrid(grid) {
  return grid.map(row => row.join("")).join("|");
}

function exportGridAsCoords(grid) {
  const coords = [];
  coords.push(gridSize);
  for (let row = 0; row < grid.length; row++) {
    for (let col = 0; col < grid[row].length; col++) {
      if (grid[row][col] === 1) {
        coords.push([row, col]);
      }
    }
  }
  
  const json = JSON.stringify(coords);
  navigator.clipboard.writeText(json).then(() => {
    alert("Grid copied as coordinates!");
  });
}

function importGridFromCoords(json) {
  try {
    const coords = JSON.parse(json);
    const newSize = coords[0];
    const newGrid = Array(newSize).fill().map(() => Array(newSize).fill(0));

    for (let i = 1; i < coords.length; i++) {
      const row = coords[i][0];
      const col = coords[i][1];
      if (row >= 0 && row < newSize && col >= 0 && col < newSize) {
        newGrid[row][col] = 1;
      }
    }

    gridSize = newSize;
    cellSize = canvas.width / gridSize;
    currentGrid = newGrid;
    history = [newGrid.map(row => row.slice())];
    currentGen = 0;
    drawGrid(currentGrid);
  } catch (e) {
    alert("Invalid coordinate format. Error: " + e);
  }
}

function resizeGrid(newSize) {
  if (newSize < 1) {
    alert("Grid size must be greater than 0");
    return;
  }

  const newGrid = Array(newSize).fill().map(() => Array(newSize).fill(0));
  for (let row = 0; row < Math.min(gridSize, newSize); row++) {
    for (let col = 0; col < Math.min(gridSize, newSize); col++) {
      newGrid[row][col] = currentGrid[row][col];
    }
    newGrid[row].length = newSize;
  }
  newGrid.length = newSize;

  gridSize = newSize;
  cellSize = canvas.width / gridSize;
  currentGrid = newGrid;
  history = [newGrid.map(row => row.slice())];
  currentGen = 0;
  drawGrid(currentGrid);
}

function startBruteForceReverse(targetGrid) {
  const influenceZone = getInfluenceZone(targetGrid);
  const visited = new Set();
  const counter = document.getElementById("attemptCounter");
  let attempt = 0;
  const batchSize = 2000;

  bruteForceRunning = true;

  bruteForceInterval = setInterval(() => {
    if (!bruteForceRunning) {
      clearInterval(bruteForceInterval);
      counter.textContent = `Stopped at attempt ${attempt}`;
      return;
    }

    let lastCandidate = null;

    for (let i = 0; i < batchSize; i++) {
      attempt++;

      const candidate = Array(gridSize).fill().map(() => Array(gridSize).fill(0));
      for (const key of influenceZone) {
        const [r, c] = key.split(',').map(Number);
        candidate[r][c] = Math.random() < 0.5 ? 1 : 0;
      }

      const zoneKey = Array.from(influenceZone).map(key => {
        const [r, c] = key.split(',').map(Number);
        return candidate[r][c];
      }).join('');

      if (visited.has(zoneKey)) continue;
      visited.add(zoneKey);

      const evolved = updateGridFrom(candidate);
      let match = true;
      for (const key of influenceZone) {
        const [r, c] = key.split(',').map(Number);
        if (evolved[r][c] !== targetGrid[r][c]) {
          match = false;
          break;
        }
      }

      if (match) {
        bruteForceRunning = false;
        clearInterval(bruteForceInterval);
        currentGrid = candidate;
        history = [currentGrid.map(row => row.slice())];
        currentGen = 0;
        drawGrid(currentGrid);
        counter.textContent = `✅ Found match at attempt ${attempt}`;
        return;
      }

      lastCandidate = candidate;
    }

    if (lastCandidate && attempt % 1000 === 0) {
      drawGrid(lastCandidate);
      counter.textContent = `Attempt ${attempt}`;
    }
  }, 0);
}

function stopBruteForceReverse() {
  bruteForceRunning = false;
  clearInterval(bruteForceInterval);
  drawGrid(currentGrid);
}

let geneticRunning = false;
let geneticInterval = null;

function startGeneticReverse(targetGrid) {
  const influenceZone = getInfluenceZone(targetGrid);
  const zoneCells = Array.from(influenceZone).map(key => key.split(',').map(Number));
  const counter = document.getElementById("attemptCounter");

  const populationSize = 100;
  const mutationRate = 0.1;
  const eliteCount = 10;

  let population = Array(populationSize).fill().map(() => randomCandidate(zoneCells));
  let generation = 0;

  geneticRunning = true;

  geneticInterval = setInterval(() => {
    if (!geneticRunning) {
      clearInterval(geneticInterval);
      counter.textContent = `Stopped at generation ${generation}`;
      return;
    }

    const scored = population.map(candidate => {
      const evolved = updateGridFrom(candidate);
      return {
        candidate,
        score: scoreCandidate(evolved, targetGrid, zoneCells)
      };
    });

    scored.sort((a, b) => b.score - a.score);

    if (scored[0].score === zoneCells.length) {
      geneticRunning = false;
      clearInterval(geneticInterval);
      currentGrid = scored[0].candidate;
      history = [currentGrid.map(row => row.slice())];
      currentGen = 0;
      drawGrid(currentGrid);
      counter.textContent = `✅ Found match at generation ${generation}`;
      return;
    }

    const elites = scored.slice(0, eliteCount).map(e => e.candidate);
    population = [];

    while (population.length < populationSize) {
      const parentA = elites[Math.floor(Math.random() * eliteCount)];
      const parentB = elites[Math.floor(Math.random() * eliteCount)];
      const child = crossover(parentA, parentB, zoneCells);
      mutate(child, zoneCells, mutationRate);
      population.push(child);
    }

    generation++;
    if (generation % 10 === 0) {
      drawGrid(scored[0].candidate);
      counter.textContent = `Generation ${generation} | Best score: ${scored[0].score}`;
    }
  }, 0);
}

function stopGeneticReverse() {
  geneticRunning = false;
  clearInterval(geneticInterval);
}

function randomCandidate(zoneCells) {
  const grid = Array(gridSize).fill().map(() => Array(gridSize).fill(0));
  for (const [r, c] of zoneCells) {
    grid[r][c] = Math.random() < 0.5 ? 1 : 0;
  }
  return grid;
}

function scoreCandidate(evolved, target, zoneCells) {
  let score = 0;
  for (const [r, c] of zoneCells) {
    if (evolved[r][c] === target[r][c]) score++;
  }
  return score;
}

function crossover(parentA, parentB, zoneCells) {
  const child = Array(gridSize).fill().map(() => Array(gridSize).fill(0));
  for (const [r, c] of zoneCells) {
    child[r][c] = Math.random() < 0.5 ? parentA[r][c] : parentB[r][c];
  }
  return child;
}

function mutate(grid, zoneCells, rate) {
  for (const [r, c] of zoneCells) {
    if (Math.random() < rate) {
      grid[r][c] = grid[r][c] === 1 ? 0 : 1;
    }
  }
}


document.getElementById("forwardBtn").addEventListener("click", function () {
  history.push(currentGrid.map(row => row.slice()));
  currentGrid = updateGrid();
  currentGen = history.length;
  drawGrid(currentGrid);
});

document.getElementById("backwardBtn").addEventListener("click", function () {
  reverseGrid();
  drawGrid(currentGrid);
});

document.getElementById("startReverseBtn").addEventListener("click", () => {
  document.getElementById("searchIndicator").style.display = "block";
  startBruteForceReverse(currentGrid);
});

document.getElementById("stopReverseBtn").addEventListener("click", () => {
  document.getElementById("searchIndicator").style.display = "none";
  stopBruteForceReverse();
});

document.getElementById("startGeneticBtn").addEventListener("click", () => {
  document.getElementById("searchIndicator").style.display = "block";
  startGeneticReverse(currentGrid);
});

document.getElementById("stopGeneticBtn").addEventListener("click", () => {
  document.getElementById("searchIndicator").style.display = "none";
  stopGeneticReverse();
  drawGrid(currentGrid);
});

document.getElementById("increaseGridBtn").addEventListener("click", () => {
  resizeGrid(gridSize + 1);
});

document.getElementById("decreaseGridBtn").addEventListener("click", () => {
  resizeGrid(gridSize - 1);
});

document.getElementById("exportBtn").addEventListener("click", () => {
  exportGridAsCoords(currentGrid);
});

document.getElementById("importBtn").addEventListener("click", () => {
  const input = prompt("Paste coordinate JSON:");
  if (input) importGridFromCoords(input);
});

document.getElementById("runBtn").addEventListener("click", function () {
  if (!running) {
    running = true;
    intervalId = setInterval(() => {
      history.push(currentGrid.map(row => row.slice()));
      currentGrid = updateGrid();
      currentGen = history.length;
      drawGrid(currentGrid);
    }, 200);
  }
});

document.getElementById("stopBtn").addEventListener("click", function () {
  running = false;
  clearInterval(intervalId);
});

document.getElementById("restartBtn").addEventListener("click", function () {
  running = false;
  clearInterval(intervalId);
  currentGrid = history[0].map(row => row.slice());
  history = [currentGrid];
  currentGen = 0;
  drawGrid(currentGrid);
});

document.getElementById("clearBtn").addEventListener("click", function () {
  running = false;
  clearInterval(intervalId);
  currentGrid = currentGrid.map(row => row.map(() => 0));
  history = [currentGrid.map(row => row.slice())];
  currentGen = 0;
  drawGrid(currentGrid);
});

canvas.addEventListener("click", function (event) {
  const rect = canvas.getBoundingClientRect();
  const x = event.clientX - rect.left;
  const y = event.clientY - rect.top;
  const col = Math.floor(x / cellSize);
  const row = Math.floor(y / cellSize);
  currentGrid[row][col] = currentGrid[row][col] === 1 ? 0 : 1;
  history = [currentGrid.map(row => row.slice())];
  currentGen = 0;
  drawGrid(currentGrid);
});

window.onload = function () {
  currentGrid = initialGrid.map(row => row.slice());
  history = [currentGrid];
  currentGen = 0;
  drawGrid(currentGrid);
};
</script>
</body>
</html>
