<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Game of Life</title>
  <style>
    body {
      height: 100vh;
      display: flex;
      flex-flow: row wrap;
      gap: 15px;
      align-items: center;
      justify-content: center;
    }
    canvas {
      border: 1px solid black;
      border-radius: 5px;
    }
    hr {
      margin: 0;
      align-self: stretch;
    }
    #menu {
      display: flex;
      flex-flow: column nowrap;
      min-width: 500px;
      padding: 5px;
      border: 1px solid black;
      border-radius: 5px;
    }
    #menu > .row {
      display: flex;
      flex-flow: row nowrap;
      padding: 0px;
      margin: 10px;
      gap: 15px;
    }
    #menu button {
      flex-grow: 1;
      text-align: center;
      font-size: 20px;
      padding: 5px;
      border: 1px solid black;
      border-radius: 5px;
    }
    #menu .icon {
      flex-grow: 0;
      align-self: center;
      aspect-ratio: 1;
      font-size: 30px;
    }
    .selection-menu {
      position: absolute;
      background: white;
      border: 1px solid #ccc;
      padding: 6px;
      z-index: 1000;
    }
  </style>
</head>
<body>
  <canvas id="lifeCanvas" width="600" height="600"></canvas><br>
  <div id="menu">
    <div id="searchIndicator" style="display:none; font-weight:bold;">Searching for reverse‚Ä¶</div>
    <div id="attemptCounter" style="font-family:monospace;"></div>
    <div class="row">
      <button id="runBtn" class="icon">‚ñ∂Ô∏è</button>
      <button id="stopBtn" class="icon" style="display: none">‚èπÔ∏è</button>
      <button id="speedDownBtn" class="icon">‚è™</button>
      <button id="speedUpBtn" class="icon">‚è©</button>
      <button id="restartBtn" class="icon">üîÑ</button>
    </div>
    <div class="row">
      <button id="backwardBtn" class="icon">‚¨Ö</button>
      <button id="forwardBtn" class="icon">‚û°</button>
      <button id="clearBtn" class="icon">‚ùé</button>
      <button id="randomizeBtn" class="icon">üîÄ</button>
    </div>
    <div class="row">
      <button id="increaseGridBtn">Increase Grid Size</button>
      <button id="decreaseGridBtn">Decrease Grid Size</button>
    </div>
    <hr>
    <div class="row">
      <button id="startReverseBtn">Start Reverse Search</button>
      <button id="stopReverseBtn">Stop Reverse Search</button>
    </div>
    <div class="row">
      <button id="startGeneticBtn">Start Genetic Reverse Search</button>
      <button id="stopGeneticBtn">Stop Genetic Reverse Search</button>
    </div>
    <div class="row" style="display: none">
      <button id="ruleBtn">Rule Based Reverse Search</button>
    </div>
    <hr>
    <div class="row">
      <button id="exportBtn" class="icon">üì§</button>
      <button id="importBtn" class="icon">üì•</button>
    </div>
  </div>
<script>
const canvas = document.getElementById("lifeCanvas");
const ctx = canvas.getContext("2d");

let gridSize = 25;
let cellSize = canvas.width / gridSize;

let isDragging = false;
let dragMode = null; // "on" or "off"

let isSelecting = false;
let selectionActive = false;
let selectionStart = null;
let selectionEnd = null;
let isDraggingSelection = false;
let dragOffset = null;
let selectedCells = [];
let selectionBounds = null;
let selectionMenu = null;

let dragOffset = { row: 0, col: 0 };

let running = false;
let intervalId = null;
let bruteForceRunning = false;
let bruteForceInterval = null;

let runInterval = 200;

const initialGrid = Array(gridSize).fill().map(() => Array(gridSize).fill(0));
initialGrid[1][2] = 1;
initialGrid[2][3] = 1;
initialGrid[3][1] = 1;
initialGrid[3][2] = 1;
initialGrid[3][3] = 1;

let currentGrid = initialGrid.map(row => row.slice());
let history = [currentGrid.map(row => row.slice())];
let currentGen = 0;

function drawGrid(grid) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (let row = 0; row < grid.length; row++) {
    for (let column = 0; column < grid[row].length; column++) {
      if (grid[row][column] === 1) {
        ctx.fillRect(column * cellSize, row * cellSize, cellSize, cellSize);
      }
    }
  }
}

function getNextState(state, neighbors) {
  return state === 1 ? (neighbors === 2 || neighbors === 3 ? 1 : 0) : (neighbors === 3 ? 1 : 0);
}

function getNeighborsSum(grid, row, col) {
  const numRows = grid.length;
  const numCols = grid[0].length;
  let sum = 0;
  for (let i = -1; i <= 1; i++) {
    for (let j = -1; j <= 1; j++) {
      if (i === 0 && j === 0) continue;
      const wrappedRow = (row + i + numRows) % numRows;
      const wrappedCol = (col + j + numCols) % numCols;
      sum += grid[wrappedRow][wrappedCol];
    }
  }
  return sum;
}

function updateGrid() {
  const newGrid = [];
  for (let row = 0; row < currentGrid.length; row++) {
    newGrid[row] = [];
    for (let col = 0; col < currentGrid[row].length; col++) {
      const neighbors = getNeighborsSum(currentGrid, row, col);
      newGrid[row][col] = getNextState(currentGrid[row][col], neighbors);
    }
  }
  return newGrid;
}

function reverseGrid() {
  if (currentGen > 0) {
    currentGen--;
    currentGrid = history[currentGen].map(row => row.slice());
  }
}

function getInfluenceZone(grid) {
  const zone = new Set();
  for (let row = 0; row < gridSize; row++) {
    for (let col = 0; col < gridSize; col++) {
      if (grid[row][col] === 1) {
        for (let dr = -1; dr <= 1; dr++) {
          for (let dc = -1; dc <= 1; dc++) {
            const r = (row + dr + gridSize) % gridSize;
            const c = (col + dc + gridSize) % gridSize;
            zone.add(`${r},${c}`);
          }
        }
      }
    }
  }
  return zone;
}

function updateGridFrom(grid) {
  const newGrid = [];
  for (let row = 0; row < grid.length; row++) {
    newGrid[row] = [];
    for (let col = 0; col < grid[row].length; col++) {
      const neighbors = getNeighborsSum(grid, row, col);
      newGrid[row][col] = getNextState(grid[row][col], neighbors);
    }
  }
  return newGrid;
}

function gridsEqual(a, b) {
  for (let row = 0; row < gridSize; row++) {
    for (let col = 0; col < gridSize; col++) {
      if (a[row][col] !== b[row][col]) return false;
    }
  }
  return true;
}

function serializeGrid(grid) {
  return grid.map(row => row.join("")).join("|");
}

function exportGridAsCoords(grid) {
  const coords = [];
  coords.push(gridSize);
  for (let row = 0; row < grid.length; row++) {
    for (let col = 0; col < grid[row].length; col++) {
      if (grid[row][col] === 1) {
        coords.push([row, col]);
      }
    }
  }
  
  const json = JSON.stringify(coords);
  navigator.clipboard.writeText(json).then(() => {
    alert("Grid copied as coordinates!");
  });
}

function importGridFromCoords(json) {
  try {
    const coords = JSON.parse(json);
    const newSize = coords[0];
    const newGrid = Array(newSize).fill().map(() => Array(newSize).fill(0));

    for (let i = 1; i < coords.length; i++) {
      const row = coords[i][0];
      const col = coords[i][1];
      if (row >= 0 && row < newSize && col >= 0 && col < newSize) {
        newGrid[row][col] = 1;
      }
    }

    gridSize = newSize;
    cellSize = canvas.width / gridSize;
    currentGrid = newGrid;
    history = [newGrid.map(row => row.slice())];
    currentGen = 0;
    drawGrid(currentGrid);
  } catch (e) {
    alert("Invalid coordinate format. Error: " + e);
  }
}

function resizeGrid(newSize) {
  if (newSize < 1) {
    alert("Grid size must be greater than 0");
    return;
  }

  const newGrid = Array(newSize).fill().map(() => Array(newSize).fill(0));
  for (let row = 0; row < Math.min(gridSize, newSize); row++) {
    for (let col = 0; col < Math.min(gridSize, newSize); col++) {
      newGrid[row][col] = currentGrid[row][col];
    }
    newGrid[row].length = newSize;
  }
  newGrid.length = newSize;

  gridSize = newSize;
  cellSize = canvas.width / gridSize;
  currentGrid = newGrid;
  history = [newGrid.map(row => row.slice())];
  currentGen = 0;
  drawGrid(currentGrid);
}

function startBruteForceReverse(targetGrid) {
  const influenceZone = getInfluenceZone(targetGrid);
  const visited = new Set();
  const counter = document.getElementById("attemptCounter");
  let attempt = 0;
  const batchSize = 2000;

  bruteForceRunning = true;

  bruteForceInterval = setInterval(() => {
    if (!bruteForceRunning) {
      clearInterval(bruteForceInterval);
      counter.textContent = `Stopped at attempt ${attempt}`;
      return;
    }

    let lastCandidate = null;

    for (let i = 0; i < batchSize; i++) {
      attempt++;

      const candidate = Array(gridSize).fill().map(() => Array(gridSize).fill(0));
      for (const key of influenceZone) {
        const [r, c] = key.split(',').map(Number);
        candidate[r][c] = Math.random() < 0.5 ? 1 : 0;
      }

      const zoneKey = Array.from(influenceZone).map(key => {
        const [r, c] = key.split(',').map(Number);
        return candidate[r][c];
      }).join('');

      if (visited.has(zoneKey)) continue;
      visited.add(zoneKey);

      const evolved = updateGridFrom(candidate);
      let match = true;
      for (const key of influenceZone) {
        const [r, c] = key.split(',').map(Number);
        if (evolved[r][c] !== targetGrid[r][c]) {
          match = false;
          break;
        }
      }

      if (match) {
        bruteForceRunning = false;
        clearInterval(bruteForceInterval);
        currentGrid = candidate;
        history = [currentGrid.map(row => row.slice())];
        currentGen = 0;
        drawGrid(currentGrid);
        counter.textContent = `Found match at attempt ${attempt}`;
        return;
      }

      lastCandidate = candidate;
    }

    if (lastCandidate && attempt % 1000 === 0) {
      drawGrid(lastCandidate);
      counter.textContent = `Attempt ${attempt}`;
    }
  }, 0);
}

function stopBruteForceReverse() {
  bruteForceRunning = false;
  clearInterval(bruteForceInterval);
  drawGrid(currentGrid);
}

let geneticRunning = false;
let geneticInterval = null;

function startGeneticReverse(targetGrid) {
  const influenceZone = getInfluenceZone(targetGrid);
  const zoneCells = Array.from(influenceZone).map(key => key.split(',').map(Number));
  const counter = document.getElementById("attemptCounter");

  const populationSize = 100;
  const mutationRate = 0.1;
  const eliteCount = 10;

  let population = Array(populationSize).fill().map(() => randomCandidate(zoneCells));
  let generation = 0;

  geneticRunning = true;

  geneticInterval = setInterval(() => {
    if (!geneticRunning) {
      clearInterval(geneticInterval);
      counter.textContent = `Stopped at generation ${generation}`;
      return;
    }

    const scored = population.map(candidate => {
      const evolved = updateGridFrom(candidate);
      return {
        candidate,
        score: scoreCandidate(evolved, targetGrid, zoneCells)
      };
    });

    scored.sort((a, b) => b.score - a.score);

    // Improve best candidate with hill climbing
    scored[0].candidate = hillClimbImprove(scored[0].candidate, targetGrid, zoneCells);

    if (scored[0].score === zoneCells.length) {
      geneticRunning = false;
      clearInterval(geneticInterval);
      currentGrid = scored[0].candidate;
      history = [currentGrid.map(row => row.slice())];
      currentGen = 0;
      drawGrid(currentGrid);
      counter.textContent = `Found match at generation ${generation}`;
      return;
    }

    const elites = scored.slice(0, eliteCount).map(e => e.candidate);
    population = [];

    while (population.length < populationSize) {
      const parentA = elites[Math.floor(Math.random() * eliteCount)];
      const parentB = elites[Math.floor(Math.random() * eliteCount)];
      const child = crossover(parentA, parentB, zoneCells);
      mutate(child, zoneCells, mutationRate);
      population.push(child);
    }

    generation++;
    if (generation % 10 === 0) {
      drawGrid(scored[0].candidate);
      counter.textContent = `Generation ${generation} | Best score: ${scored[0].score}`;
    }
  }, 0);
}

function stopGeneticReverse() {
  geneticRunning = false;
  clearInterval(geneticInterval);
}

function randomCandidate(zoneCells) {
  const grid = Array(gridSize).fill().map(() => Array(gridSize).fill(0));
  for (const [r, c] of zoneCells) {
    grid[r][c] = Math.random() < 0.5 ? 1 : 0;
  }
  return grid;
}

function scoreCandidate(evolved, target, zoneCells) {
  let score = 0;
  for (const [r, c] of zoneCells) {
    if (evolved[r][c] === target[r][c]) score++;
  }
  return score;
}

function crossover(parentA, parentB, zoneCells) {
  const child = Array(gridSize).fill().map(() => Array(gridSize).fill(0));
  for (const [r, c] of zoneCells) {
    child[r][c] = Math.random() < 0.5 ? parentA[r][c] : parentB[r][c];
  }
  return child;
}

function mutate(grid, zoneCells, rate) {
  for (const [r, c] of zoneCells) {
    if (Math.random() < rate) {
      grid[r][c] = grid[r][c] === 1 ? 0 : 1;
    }
  }
}

function hillClimbImprove(grid, targetGrid, zoneCells) {
  let bestScore = scoreCandidate(updateGridFrom(grid), targetGrid, zoneCells);
  let improved = true;

  while (improved) {
    improved = false;

    for (const [r, c] of zoneCells) {
      // Flip cell
      grid[r][c] = grid[r][c] === 1 ? 0 : 1;

      const newScore = scoreCandidate(updateGridFrom(grid), targetGrid, zoneCells);

      if (newScore > bestScore) {
        bestScore = newScore;
        improved = true;
        break; // Accept the change and restart loop
      } else {
        // Revert flip
        grid[r][c] = grid[r][c] === 1 ? 0 : 1;
      }
    }
  }

  return grid;
}

function reverseByConstraints(targetGrid) {
  const gridSize = targetGrid.length;
  const predecessor = Array(gridSize).fill().map(() => Array(gridSize).fill(0));

  // Step 1: Copy all live cells from target
  for (let row = 0; row < gridSize; row++) {
    for (let col = 0; col < gridSize; col++) {
      if (targetGrid[row][col] === 1) {
        predecessor[row][col] = 1;
      }
    }
  }

  // Step 2: Add supporting neighbors to help evolution
  for (let row = 0; row < gridSize; row++) {
    for (let col = 0; col < gridSize; col++) {
      if (targetGrid[row][col] === 1) {
        let added = 0;
        for (let dr = -1; dr <= 1; dr++) {
          for (let dc = -1; dc <= 1; dc++) {
            if (dr === 0 && dc === 0) continue;
            const r = (row + dr + gridSize) % gridSize;
            const c = (col + dc + gridSize) % gridSize;
            if (predecessor[r][c] === 0 && Math.random() < 0.3) {
              predecessor[r][c] = 1;
              added++;
              if (added >= 2) break;
            }
          }
          if (added >= 2) break;
        }
      }
    }
  }

  return predecessor;
}


function incrementNeighbors(counts, r, c, size) {
  for (let dr = -1; dr <= 1; dr++) {
    for (let dc = -1; dc <= 1; dc++) {
      if (dr === 0 && dc === 0) continue;
      const nr = (r + dr + size) % size;
      const nc = (c + dc + size) % size;
      counts[nr][nc]++;
    }
  }
}


function getCellFromEvent(event) {
  const rect = canvas.getBoundingClientRect();
  const x = event.clientX - rect.left;
  const y = event.clientY - rect.top;
  return [
    Math.floor(y / cellSize),
    Math.floor(x / cellSize)
  ];
}


function applyDrag(row, col) {
  if (row < 0 || row >= gridSize || col < 0 || col >= gridSize) return;
  const current = currentGrid[row][col];
  const target = dragMode === "on" ? 1 : 0;
  if (current !== target) {
    currentGrid[row][col] = target;

    // Clear history when a change is made
    history = [currentGrid.map(row => row.slice())];
    currentGen = 0;
    
    drawGrid(currentGrid);
  }
}

function randomizeGrid() {
  for (let i = 0; i < currentGrid.length; i++) {
    for (let j = 0; j < currentGrid[i].length; j++) {
      const target = Math.random() < 0.5 ? 1 : 0;
      currentGrid[i][j] = target;
    }
  }
}

function drawSelectionBox(start, end) {
  const x1 = Math.min(start.col, end.col);
  const y1 = Math.min(start.row, end.row);
  const x2 = Math.max(start.col, end.col);
  const y2 = Math.max(start.row, end.row);

  ctx.strokeStyle = 'red';
  ctx.lineWidth = 2;
  ctx.strokeRect(x1 * cellSize, y1 * cellSize, (x2 - x1 + 1) * cellSize, (y2 - y1 + 1) * cellSize);
}

function openSelectionMenu(start, end) {
  document.querySelectorAll('.selection-menu').forEach(el => el.remove());

  selectionMenu = document.createElement('div');
  selectionMenu.className = 'selection-menu';
  selectionMenu.style.position = 'absolute';
  selectionMenu.style.left = `${end.col * cellSize}px`;
  selectionMenu.style.top = `${end.row * cellSize}px`;
  selectionMenu.innerHTML = `
    <button id="moveBtn">Move</button>
    <button onclick="deleteSelection(${start.row}, ${start.col}, ${end.row}, ${end.col})">Delete</button>
    <button onclick="exportSelection(${start.row}, ${start.col}, ${end.row}, ${end.col})">Export</button>
  `;
  document.body.appendChild(selectionMenu);

  // Attach listener after menu is added
  const moveBtn = document.getElementById("moveBtn");
  moveBtn.addEventListener("mousedown", (e) => {
    e.preventDefault();
    e.stopPropagation();
    isDraggingSelection = true;
    dragOffset = getCellFromMouse(e);
  });
}


function deleteSelection(r1, c1, r2, c2) {
  selectionActive = false;
  for (let r = r1; r <= r2; r++) {
    for (let c = c1; c <= c2; c++) {
      currentGrid[r][c] = 0;
    }
  }
  drawGrid(currentGrid);
}

function exportSelection(r1, c1, r2, c2) {
  selectionActive = false;
  const coords = [];
  for (let r = r1; r <= r2; r++) {
    for (let c = c1; c <= c2; c++) {
      if (currentGrid[r][c] === 1) {
        coords.push([r, c]);
      }
    }
  }
  console.log("Exported coordinates:", JSON.stringify(coords));
}

function captureSelection(r1, c1, r2, c2) {
  selectedCells = [];
  selectionBounds = { r1, c1, r2, c2 };

  for (let r = r1; r <= r2; r++) {
    for (let c = c1; c <= c2; c++) {
      if (currentGrid[r][c] === 1) {
        selectedCells.push({ row: r - r1, col: c - c1 });
        // don't modify currentGrid here
      }
    }
  }

  drawGrid(currentGrid);
  drawSelectionBox({ row: r1, col: c1 }, { row: r2, col: c2 });
}


function drawFloatingSelection(baseRow, baseCol) {
  if (!isDraggingSelection || !selectedCells || selectedCells.length === 0) return;

  ctx.fillStyle = 'lime';
  for (const cell of selectedCells) {
    const r = baseRow + cell.row;
    const c = baseCol + cell.col;
    ctx.fillRect(c * cellSize, r * cellSize, cellSize, cellSize);
  }
}


function placeSelection(baseRow, baseCol) {
  for (const cell of selectedCells) {
    const r = baseRow + cell.row;
    const c = baseCol + cell.col;
    if (r >= 0 && r < gridSize && c >= 0 && c < gridSize) {
      currentGrid[r][c] = 1;
    }
  }

  // Clear selection state
  selectedCells = [];
  selectionBounds = null;
  isDraggingSelection = false;

  drawGrid(currentGrid);
}



document.getElementById("forwardBtn").addEventListener("click", function () {
  history.push(currentGrid.map(row => row.slice()));
  currentGrid = updateGrid();
  currentGen = history.length;
  drawGrid(currentGrid);
});

document.getElementById("backwardBtn").addEventListener("click", function () {
  reverseGrid();
  drawGrid(currentGrid);
});

document.getElementById("startReverseBtn").addEventListener("click", () => {
  document.getElementById("searchIndicator").style.display = "block";
  startBruteForceReverse(currentGrid);
});

document.getElementById("stopReverseBtn").addEventListener("click", () => {
  document.getElementById("searchIndicator").style.display = "none";
  stopBruteForceReverse();
});

document.getElementById("startGeneticBtn").addEventListener("click", () => {
  document.getElementById("searchIndicator").style.display = "block";
  startGeneticReverse(currentGrid);
});

document.getElementById("stopGeneticBtn").addEventListener("click", () => {
  document.getElementById("searchIndicator").style.display = "none";
  stopGeneticReverse();
  drawGrid(currentGrid);
});

document.getElementById("ruleBtn").addEventListener("click", () => {
  const reversed = reverseByConstraints(currentGrid);
  currentGrid = reversed;
  history = [reversed.map(row => row.slice())];
  currentGen = 0;
  drawGrid(currentGrid);
});

document.getElementById("increaseGridBtn").addEventListener("click", () => {
  resizeGrid(gridSize + 1);
});

document.getElementById("decreaseGridBtn").addEventListener("click", () => {
  resizeGrid(gridSize - 1);
});

document.getElementById("exportBtn").addEventListener("click", () => {
  exportGridAsCoords(currentGrid);
});

document.getElementById("importBtn").addEventListener("click", () => {
  const input = prompt("Paste coordinate JSON:");
  if (input) importGridFromCoords(input);
});

document.getElementById("runBtn").addEventListener("click", function () {
  if (!running) {
    running = true;
    intervalId = setInterval(() => {
      history.push(currentGrid.map(row => row.slice()));
      currentGrid = updateGrid();
      currentGen = history.length;
      drawGrid(currentGrid);
    }, runInterval);
  }
  document.getElementById("runBtn").style.display = "none";
  document.getElementById("stopBtn").style.display = "block";
});

document.getElementById("stopBtn").addEventListener("click", function () {
  running = false;
  clearInterval(intervalId);
  document.getElementById("stopBtn").style.display = "none";
  document.getElementById("runBtn").style.display = "block";
});

document.getElementById("speedUpBtn").addEventListener("click", function () {
  runInterval *= 0.9; // Speed up by 10%
  if(running) {
    document.getElementById("stopBtn").click();
    document.getElementById("runBtn").click();
  }
});

document.getElementById("speedDownBtn").addEventListener("click", function () {
  runInterval *= 1.1; // Slow down by 10%
  if(running) {
    document.getElementById("stopBtn").click();
    document.getElementById("runBtn").click();
  }
});

document.getElementById("restartBtn").addEventListener("click", function () {
  running = false;
  clearInterval(intervalId);
  currentGrid = history[0].map(row => row.slice());
  history = [currentGrid.map(row => row.slice())];
  currentGen = 0;
  drawGrid(currentGrid);
});

document.getElementById("clearBtn").addEventListener("click", function () {
  running = false;
  clearInterval(intervalId);
  currentGrid = currentGrid.map(row => row.map(() => 0));
  history = [currentGrid.map(row => row.slice())];
  currentGen = 0;
  drawGrid(currentGrid);
});

document.getElementById("randomizeBtn").addEventListener("click", function () {
  running = false;
  randomizeGrid();
  history = [currentGrid.map(row => row.slice())];
  currentGen = 0;
  drawGrid(currentGrid);
});

canvas.addEventListener("mousedown", function (event) {
  const [row, col] = getCellFromEvent(event);

  if (event.button === 2) { // right-click
    event.preventDefault();
    isSelecting = true;
    selectionStart = { row, col };
    selectionEnd = { row, col };
    drawGrid(currentGrid);
    drawSelectionBox(selectionStart, selectionEnd);
  } else if (event.button === 0) { // left-click
    isDragging = true;
    dragMode = currentGrid[row][col] === 1 ? "off" : "on";
    applyDrag(row, col);
  }
});

canvas.addEventListener("touchstart", function (event) {
  const [row, col] = getCellFromEvent(event);
  isDragging = true;
  dragMode = currentGrid[row][col] === 1 ? "off" : "on";
  applyDrag(row, col);
});

canvas.addEventListener("touchmove", function (event) {
  if (!isDragging) return;
  const [row, col] = getCellFromEvent(event);
  applyDrag(row, col);
});

canvas.addEventListener("touchend", function () {
  isDragging = false;
  dragMode = null;
});
canvas.addEventListener("touchcancel", function () {
  isDragging = false;
  dragMode = null;
});


canvas.addEventListener('contextmenu', e => e.preventDefault()); // prevent default right-click
  canvas.addEventListener("touchstart", e => e.preventDefault(), { passive: false }); // prevent default touch scroll


canvas.addEventListener("mousemove", function (event) {
  const { row, col } = getCellFromMouse(event);

  if (isDraggingSelection) {
    const { row, col } = getCellFromMouse(event);
    const deltaRow = row - dragOffset.row;
    const deltaCol = col - dragOffset.col;
    dragOffset = { row, col };

    selectionBounds.r1 += deltaRow;
    selectionBounds.r2 += deltaRow;
    selectionBounds.c1 += deltaCol;
    selectionBounds.c2 += deltaCol;

    // Move the menu
    selectionMenu.style.left = `${selectionBounds.c2 * cellSize}px`;
    selectionMenu.style.top = `${selectionBounds.r2 * cellSize}px`;

    drawGrid(currentGrid);
    drawFloatingSelection(selectionBounds.r1, selectionBounds.c1);
  } else if (isDragging) {
    const [r, c] = getCellFromEvent(event);
    applyDrag(r, c);
  } else if (isSelecting) {
    selectionEnd = getCellFromMouse(event);
    drawGrid(currentGrid);
    drawSelectionBox(selectionStart, selectionEnd);
  }
});

document.addEventListener("mousemove", function (event) {
  if (!isDraggingSelection) return;

  const { row, col } = getCellFromMouse(event);
  const deltaRow = row - dragOffset.row;
  const deltaCol = col - dragOffset.col;
  dragOffset = { row, col };

  selectionBounds.r1 += deltaRow;
  selectionBounds.r2 += deltaRow;
  selectionBounds.c1 += deltaCol;
  selectionBounds.c2 += deltaCol;

  if (selectionMenu) {
    selectionMenu.style.left = `${selectionBounds.c2 * cellSize}px`;
    selectionMenu.style.top = `${selectionBounds.r2 * cellSize}px`;
  }

  drawGrid(currentGrid);
  drawFloatingSelection(selectionBounds.r1, selectionBounds.c1);
});

document.addEventListener("mouseup", function () {
  if (!isDraggingSelection) return;

  isDraggingSelection = false;
  placeSelection(selectionBounds.r1, selectionBounds.c1);
  selectedCells = [];
  selectionBounds = null;

  if (selectionMenu) {
    selectionMenu.remove();
    selectionMenu = null;
  }

  drawGrid(currentGrid);
});


canvas.addEventListener("mouseup", function (event) {
  if (isDragging) {
    isDragging = false;
    dragMode = null;
  }

  if (isSelecting && event.button === 2) {
    isSelecting = false;
    const r1 = Math.min(selectionStart.row, selectionEnd.row);
    const r2 = Math.max(selectionStart.row, selectionEnd.row);
    const c1 = Math.min(selectionStart.col, selectionEnd.col);
    const c2 = Math.max(selectionStart.col, selectionEnd.col);
    selectionBounds = { r1, r2, c1, c2 };
    captureSelection(r1, c1, r2, c2);
    openSelectionMenu({ row: r1, col: c1 }, { row: r2, col: c2 });
  }
  if (isDraggingSelection) {
    isDraggingSelection = false;
    placeSelection(selectionBounds.r1, selectionBounds.c1);
    selectedCells = [];
    selectionBounds = null;

    if (selectionMenu) {
      selectionMenu.remove();
      selectionMenu = null;
    }

    drawGrid(currentGrid);
  }

  isDragging = false;
  dragMode = null;
});

document.addEventListener('click', function (e) {
  const menu = document.querySelector('.selection-menu');
  if (menu && !menu.contains(e.target)) {
    menu.remove();
  }
});


window.onload = function () {
  currentGrid = initialGrid.map(row => row.slice());
  history = [currentGrid.map(row => row.slice())];
  currentGen = 0;
  drawGrid(currentGrid);
};
</script>
</body>
</html>
