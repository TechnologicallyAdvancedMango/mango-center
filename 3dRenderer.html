<!DOCTYPE html>
<html>
<head>
  <title>3D Wireframe Renderer</title>
  <style>
    canvas {
      border: 1px solid black;
      background: #fff;
      display: block;
      margin: auto;
    }
  </style>
</head>
<body>
<canvas id="viewport" width="800" height="600"></canvas>

<script>
const canvas = document.getElementById('viewport');
const ctx = canvas.getContext('2d');
const width = canvas.width;
const height = canvas.height;

const camera = {
  position: [0, 0, 0],
  rotation: [0, 0, 0] // pitch (x), yaw (y)
};

const keys = {};
document.addEventListener('keydown', e => keys[e.key] = true);
document.addEventListener('keyup', e => keys[e.key] = false);

function getForwardVector(camera) {
  const [pitch, yaw] = camera.rotation;
  return [
    Math.sin(yaw) * Math.cos(pitch),
    Math.sin(pitch),
    Math.cos(yaw) * Math.cos(pitch)
  ];
}

function updateCamera(camera) {
  const speed = 0.1;
  const rotSpeed = 0.02;
  const pitch = camera.rotation[0];
  const yaw = camera.rotation[1];

  // Forward vector
  const forward = [
    Math.sin(yaw) * Math.cos(pitch),
    -Math.sin(pitch),
    Math.cos(yaw) * Math.cos(pitch)
  ];

  // Right vector
  const right = [
    Math.cos(yaw),
    0,
    -Math.sin(yaw)
  ];

  // Movement
  if (keys['w']) {
    camera.position[0] += forward[0] * speed;
    camera.position[1] += forward[1] * speed;
    camera.position[2] += forward[2] * speed;
  }
  if (keys['s']) {
    camera.position[0] -= forward[0] * speed;
    camera.position[1] -= forward[1] * speed;
    camera.position[2] -= forward[2] * speed;
  }
  if (keys['a']) {
    camera.position[0] -= right[0] * speed;
    camera.position[2] -= right[2] * speed;
  }
  if (keys['d']) {
    camera.position[0] += right[0] * speed;
    camera.position[2] += right[2] * speed;
  }
  if (keys['q']) camera.position[1] -= speed;
  if (keys['e']) camera.position[1] += speed;

  // Rotation
  if (keys['ArrowLeft']) camera.rotation[1] += rotSpeed;
  if (keys['ArrowRight']) camera.rotation[1] -= rotSpeed;
  if (keys['ArrowUp']) camera.rotation[0] += rotSpeed;
  if (keys['ArrowDown']) camera.rotation[0] -= rotSpeed;
}


function rotateY([x, y, z], angle) {
  const cos = Math.cos(angle), sin = Math.sin(angle);
  return [x * cos - z * sin, y, x * sin + z * cos];
}

function rotateX([x, y, z], angle) {
  const cos = Math.cos(angle), sin = Math.sin(angle);
  return [x, y * cos - z * sin, y * sin + z * cos];
}

function applyCameraTransform([x, y, z], camera) {
  // Translate world relative to camera
  x -= camera.position[0];
  y -= camera.position[1];
  z -= camera.position[2];

  // Rotate world opposite to camera rotation
  // Apply yaw first, then pitch
  [x, z] = [
    x * Math.cos(-camera.rotation[1]) - z * Math.sin(-camera.rotation[1]),
    x * Math.sin(-camera.rotation[1]) + z * Math.cos(-camera.rotation[1])
  ];
  [y, z] = [
    y * Math.cos(-camera.rotation[0]) - z * Math.sin(-camera.rotation[0]),
    y * Math.sin(-camera.rotation[0]) + z * Math.cos(-camera.rotation[0])
  ];

  return [x, y, z];
}


function project([x, y, z], width, height, fov = 300) {
  const scale = fov / (z + 5);
  return [x * scale + width / 2, y * scale + height / 2];
}

function createCube(size = 1) {
  const s = size / 2;
  const vertices = [
    [-s, -s, -s], [s, -s, -s],
    [s, s, -s], [-s, s, -s],
    [-s, -s, s], [s, -s, s],
    [s, s, s], [-s, s, s]
  ];
  const edges = [
    [0,1],[1,2],[2,3],[3,0],
    [4,5],[5,6],[6,7],[7,4],
    [0,4],[1,5],[2,6],[3,7]
  ];
  return { vertices, edges };
}

function renderShape(ctx, shape, transformFn, camera, projectFn, width, height) {
  const transformed = shape.vertices.map(v => {
    const world = transformFn(v);
    const view = applyCameraTransform(world, camera);
    return projectFn(view, width, height);
  });

  shape.edges.forEach(([a, b]) => {
    const [x1, y1] = transformed[a];
    const [x2, y2] = transformed[b];
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
  });
}

const shapes = [
  { shape: createCube(1), offset: [-2, 0, 5] },
  { shape: createCube(1), offset: [2, 0, 5] }
];

let angle = 0;
function loop() {
  ctx.clearRect(0, 0, width, height);
  updateCamera(camera);

  shapes.forEach(({ shape, offset }) => {
    const transform = v => {
      let [x, y, z] = rotateY(v, angle);
      return [x + offset[0], y + offset[1], z + offset[2]];
    };
    renderShape(ctx, shape, transform, camera, project, width, height);
  });

  angle += 0.01;
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
